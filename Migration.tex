\chapter{Migration}

	Im vorherigen Kapitel wurden Module und ihre Eingenschaften, Konstruktionsregeln sowie Arten behandelt. 
	Dieses Kapitel beschäftigt sich mit der Fragestellung, wie Altsysteme, die vor Java 9 entwickelt worden sind, auf dem Modulsystem betrieben werden können und was getan werden muss, um diese den modernen Anforderung anzupassen und vollständig zu Modularisieren.\bigbreak

	Software die nicht beständig auf dem aktuellen Stand der Technik gehalten wird rutscht langsam in den Bereich der Altsysteme. Die Altsysteme werden oft als Legacy-Systeme bezeichnet, da diese lange Lebenszyklen besitzen und viele Code aus früheren Entwicklungszyklen mit sich tragen. Der Transfer dieser Systeme in eine neue Umgebung, ohne Änderungen der internen Struktur, bezeichnet man als Migration. Diese wird oft im Bereich der Softwaretechnik mit Software Reengineering und Software Neuimplementation verwechselt, dessen Zielsetzungen in der Optimierung der Codebasis liegen und nichts mit dem Ausführungskontext zu tun haben. \bigbreak

	% Migrationsmethoden und der von ihnen gelösten Problemen. 
	Die Migration von Anwendungen ist eine wiederkehrendes Ereignis im Lebenszyklus einer lang gepflegten Kernapplikation.
	Zum Beispiele kann eine Applikation an Größe gewinnen und muss in die Cloud ausgelagert werden, die Anforderungen können sich verschieben und der Technologie-Stack muss an die Marktbedürfnisse angepasst werden, darüber hinaus kann der Ausführungskontext einen großen Versionssprung hinter sich lassen, der das Warten der Software unter den momentanen Bedingungen unmöglich macht. Das Umfeld der Software Entwicklung ist eine dynamische Umgebung, denn auch mit einer gut durchdachte Architektur kann nicht garantiert werden, dass in der Zukunft heutige Paradigmen, Werkzeuge und Aufgabenbereiche den selben Kurs behalten. Deswegen existieren bereits sämtliche Migrationsstrategien, die als ein Leitpfaden den Entwicklung während der Migration führen. \bigbreak

	Im folgenden Kapitel werden Ansätze vorgestellt, die Anwendungen aus dem monolithischen System in das modulare System überführen ohne Änderung an der interne Funktionalität durchzuführen. 


\section{Legacy-System}

	Der Begriff \textit{Legacy-System} beschreibt ein altes System, das innerhalb einer Organisation länger als der implementierte Lebenszyklus in Betrieb bleibt. Der englische Begriff \textit{Legacy}, zu deutsch Erbe, bezieht sich nicht auf das Alter der Software, sondern auf die Interpretation der Software als Erbe. Die Entwicklung wurde von früheren Entwicklern und Teams durchgeführt. Damalige Konzeptentscheidungen ergeben ein Erbe, das für die zukünftige Erweiterung der Software eine große Rolle spielt. Legacy-Systeme wurden typischerweise gemäß der veralteten Praxis und Technologie entwickelt. Sie haben lange Lebenszyklen mit umfangreichen Veränderungen und Erweiterungen erfahren \cite{sneed2016softwaremigration}.

\subsection{Eigenschaften}

	Bei Legacy-Systemen handelt es sich oft um sogenannte Kernsysteme, zur Unterstützung wesentlicher Geschäftsprozesse eines Unternehmens. Sie sind in der Regel geschäftskritisch und können nicht ohne größeren Aufwand und Risiko für das Unternehmen ausgetauscht werden. Aufgrund ihres langen Lebenszyklus, ihrer Komplexität und ständigen Überarbeitungen ist die Logik solcher Systeme oft unübersichtlich. Geschäftsprozesse und Geschäftsregeln sind im Code versteckt und müssten für z.\,B. eine Neuimplementation erst rekonstruiert werden \cite{martens2016ablosung}.

	Zu diesem Punkt gesellt sich die Eigenschaft, dass Legacy-Systeme oft sehr schlecht dokumentiert und strukturiert sind. Ihre Implementierung könnte zudem früher geltenden Standards unterliegen und anderen Programmierparadigmen folgen, die nur schwer verständlich sind \cite{stahlknecht2002einfuhrung}.

\section{Migration} \label{ssub:migration}

	% schau in diesem buch nach einer defenition  mit den storchen 
	Softwaremigration bezeichnet die Überführung eines Softwaresystems in eine andere Zielumgebung oder in eine sonstige andere Form, wobei die fachliche Funktionalität unverändert bleibt. Als Ausgangspunkt steht dabei immer ein bestehendes System, das auf sich ändernde Anforderungen und Techniken des Anwendungsbereiches angepasst werden muss \cite{sneed2016softwaremigration}.

\section{Migrationshürden} \label{MigH}

	% Einleitung: hier kommen allgemeinen Beispiele der Migrationsproblematik 
	Die Migrationshürden sind fest mit dem Anwendungskontext verbunden und hängen stark von den Beschaffenheit der neuen Umgebung ab. Da in unserem Fall die Migration innerhalb der Java Umgebung stattfindend, müssen die Neuerungen des Modulsystem analysiert und auf die bestehenden Zustand der Applikation abgebildet werden.\bigbreak

\begin{itemize}
	% Hauptteil: Probleme und Hürden, die der neue Kontext macht
	\item Die Probleme bei dem Modulsystem beginnen mit den Zugriffsrechten auf die Core-JDK API's. Diese sind ab sofort in dem Module gekapselt und bieten keine Möglichkeit sie aufzurufen. Nichtsdestotrotz stellt Java für viele der gekapselten API's einen Ersatz zur Verfügung, wodurch zahlreiche Probleme mit einem relativ geringen Aufwand behoben werden können. 


	\item Im Weiteren verbietet das neue Modulsystem namensgleiche Pakete in verschiedenen Modulen. Dieses adressiert das vorher besprochene Problem aus dem Kapitel \ref{sec:nam}, nämlich den Zugriff auf privat deklarierte Pakete aus fremden Modulen. Trotz dem gibt es Bibliotheken mit ähnlicher Paketstruktur die nicht böswillig sich Zugriff verschaffen wollen, sondern spiegeln eine Standardstruktur einer Bibliothek wieder, wie zum Beispiel \textit{de.firma.input.reader} kann in mehreren Bibliotheken eines Unternehmens existieren und wird ab Java 9 nicht mehr zulässig sein. Somit müssen Module mit ähnlicher Struktur angepasst werden um den nächsten Modularisierungsschritt durchführen zu können.


	\item Der Classloader-Typ des Applikation-Classloaders wurden überarbeitet und infolgedessen auch das Arbeit mit den ehemaligen URLClassloader Methoden. Der bestehende Code, der den URLClassloader exzessiv nutzt und zum Beispiel Ressourcen aus verschiedenen Quellen lädt, muss auf den \textit{SecureClassLoader} oder  \textit{ClassLoader} aufgewertet werden, um funktionstüchtig zu bleiben. 


	\item Einer der Kritischen Veränderungen, die die Modultatform mit sich bringt, ist der Verbot von zyklischen Abhängigkeiten von Modulen untereinander. Diese dürfen sich nicht gegenseitig mit den Schlüssel \textit{require} koppeln, da sonst eine Veränderung in einem Module zwangsläufig eine Änderung im anderen Module hervorrufen kann. Dieser Still kann sich schnell über die ganze Applikation verbreiten und kleine Änderungen an einer Stelle zu unübersichtlichen Seiteneffekten führen. Genau diese Probleme adressiert das Modulsystem in erster Linie und verbiete aus diesem Grund Zyklen in den Applikationsentwurf. Um bestehende Zyklen in einer Applikation zu lösen, muss die Funktionalität genau betrachtet und in kleine unabhängige Aufgaben aufgeteilt werden. Somit wäre der Zyklus aufgebrochen und die Aufgabestellung jedes Moduls klar definiert. 
\end{itemize}

\section{Migrationsarten} \label{Migratiosarten}

	% Schluss: Bewegen uns auf die möglichen Migrationsstrategien für die Modularisierung.
	Da jede Applikation spezifisch Migrationsanforderungen besitzt, gibt es unterschiedliche Verfahren, die sich bestimmten Kriterien widmen. Dementsprechend sollte man die gegebene Applikationsbeschaffenheit ermitteln und dessen Probleme auf die passende Migrationsstrategie abbilden. Die prominenten Migrationsstrategien der Software Techniken sind \textit{Chicken Little} und \textit{Butterfly}, die zwei der gängigsten Arten der Softwaresystem Migration beschreiben.\bigbreak


	% Chicken Little
	Softwaresysteme, die nach dem \textit{Chicken-Little-Ansatz} migriert werden, zerlegen das System in mehrere Migrationspakete, die einzeln in kleinen inkrementellen Schritten in die neue Zielumgebung überführt werden. Damit der Betrieb des Systems nicht für die Zeitdauer der Migration ausfällt, existieren alte, neue und migrierte Teilsysteme nebeneinander. Die korrekte Kommunikation der Softwarebausteine muss über entsprechende Kommunikationskanäle errichtet werden und gestaltetet damit einen Brücke zwischen Alt- und Neuentwicklung, die zusammen einen gemeinsame Ressourcenbasis nutzen können. \bigbreak

	% Butterfly 
	Der \textit{Butterfly-Ansatz} geht von einer separaten Entwicklung der Applikation in der neuen Umgebung aus. Dies hat zu folge dass die Altapplikation in Betrieb bleibt und unverändert ihre Aufgabe erfüllt, bis der Nachfolger, der parallel zu dem Betrieb entwickelt und getestet wird, die Funktion korrekt widerspiegeln kann. Im Anschluss werden Ressourcenbestände in kleinen Paketen an die Applikation im neuen Kontext transferiert und das Altsystem abgeschaltet. Das Butterfly-Verfahren vermeidet also während der Migration den simultanen Zugriff auf Legacy- und Zielsystem. \bigbreak

	% Ein text der auf die nächsten Kalitel einführt 
	Zwischen den beiden vorgestellten \textit{Migrationsideen} hat sich das Java Team für die Unterstützung der Schrittweise-Migration entscheiden, die eine Applikation in kleine Softwareeinheiten aufteilt und langsam auf den neuen Modulpfad migriert. Der parallele Betrieb der neuen sowie alten Struktur wird durch eine interne Brücke, die korrekte Kommunikation zwischen den Klassenpfad und den Modulpfad errichtet umgesetzt. Die Implementation der Kommunikationsbrücke und ihrer Charakteristika, die eine kritische und verantwortungsvolle Aufgabe in der Migrationsprozess trägt, wird für uns von dem Java Team zur Verfügung gestellt. Somit unterstützt und führt das Modulsystem von Java den Entwickler bei der Hand zu der korrekten, sicheren, modernen und funktionstüchtigen Modularchitektur. 


	Ungeachtet dessen ist die Migration einer kompletten Applikation auf das Modulsystem weiterhin möglich, da diese keine spezielle Hilfsmittel von der Umgebung verlangt. 


\subsection{Plattform Migration}

	Die simpelste Migration ist eine reine Plattform Migration ohne Änderungen an der Software vorzunehmen, wie in der Abbildung \ref{fig:PM} dargestellt. Dies ist möglich, dank der Unterstützung des Klassenpfades, der in diesem Fall unsere Applikation als ein \textit{unbenanntes Modul} im Modulsystem betreibt. Wie bereits im Kapitel \ref{Modularten} angesprochen, bietet dieses Modul den Betrieb der Legacy Anwendung in der neuen Umgebung mit dem geringen Anteil der möglichen Vorteilen, wie zum Beispiel den Sicherheitsupdates. Zusätzlich behält die Applikation ihre monolithisch Architektur und vermisst alle Modulsystem Features die im Kapitel \ref{sec:ZdM} und \ref{sec:ME} angesprochen wurden.

	\begin{figure}[h]
		\centering
	    \includegraphics[width=0.8\textwidth]{material/images/plattform-migration.png}
	    \caption{Plattform Migration}
	    \label{fig:PM}
  	\end{figure}

	Eine weitere Möglichkeit wäre es die Applikation und ihre Bibliotheken auf den Modulpfad zu migrieren und als \textit{automatische Module} zu betreiben. Somit wäre der alte Klassenpfad  nicht mehr im Applikationsdesign vorgesehen und fokussiert die Entwickler auf die Arbeit mit dem Modulpfad. Dennoch lässt sich nicht jede Anwendung in diesem Still migrieren, denn die Hürden aus den Kapitel \ref{MigH}, wie die \textit{Zyklen-Freiheit} sowie der verbot der \textit{Split-Packages} in Legacy Bibliotheken nicht immer gegeben ist. 



\subsection{Top Down Migration}

	Die \textit{Top-Down} Migration behandelt die Migration von Oben nach Unten, dabei werden zuerst die Applikation und im Nachhinein die Drittanbieter Bibliotheken migriert. Dafür müssen die Applikationspakete auf Abhängigkeiten geprüft und entsprechende Module sowie Modulbeschreibungen nach den im Kapitel \ref{sec:MEK} besprochenen Kriterien erstellt werden. Mit dieser Methode werden die Drittanbieter Bibliotheken zuletzt betrachtet, da es bei diesen um Fremdcode handelt. 


	Der im ersten Schritt erstellter Abhängigkeitsgraph verweist ab einen gewissen Punkt die Bibliotheksabhängigkeit der Applikation, die wiederum von weiteren Bibliotheken abhängen. Somit können die Wurzel der benötigten Drittanbieter Bibliotheken einer Applikation ausfindig gemacht und als \textit{automatische Module} in den Modulpfad eingebunden werden. Somit können diese, wie bereits in im Kapitel \ref{Modularten} behandelt, sowohl mit der Applikation als auch mit den Legacy Elementen ihrer eigener Abhängigkeiten zugleich interagieren. Zum Schluss kümmert man sich um die Bibliotheken auf dem Klassenpfad, indem diese ersetzt oder selbständig weiterentwickelt werden, mit dem Ziel die Gesamtapplikation auf dem Modulpfad zu übertragen. \bigbreak

	\begin{figure}[h]
		\centering
	    \includegraphics[width=0.8\textwidth]{material/images/top-down-migration.png}
	    \caption{\textit{Top Down} Migration}
	    \label{fig:TDM}
  	\end{figure}

	Diese Migration ist besonders vorteilhaft bei Applikationen, die eine geringe Codebasis besitzen und in einem kurzen Zeitraum eine modularisierte Form annehmen können. 


\subsection{Bottom Up Migration} \label{sec:bottomUP}

	\begin{figure}[h]
		\centering
	    \includegraphics[width=0.8\textwidth]{material/images/bottom-up-migration.png}
	    \caption{\textit{Bottom Up} Migration}
	    \label{fig:BUM}
  	\end{figure}

	Die \textit{Bottom Up} Migration behandelt lose Module zuerst, denn diese haben keine Abhängigkeiten und bieten eine gekapselte Funktionalität an. Um herauszufinden welche Module sich für den initialen Migrationsschritt eignen, kann der Abhängigkeitsgraph mit Hilfe des \textit{JDepth} erstellt werden. Module die als Blätter aufzufinden sind, können zuerst migriert werden, da sie keine Kinderknoten und somit keine Abhängigkeiten besitzen. Im weiteren Verlauf der Migration werden die übrig gebliebenen und neu entstandenen Blätter des Abhängigkeitsbaums abgearbeitet, bis die ganze Applikation, samt der Drittanbieter Bibliotheken, sich auf dem Modulpfad befindet. Während der Migration müssen natürlich die im Kapitel \ref{sec:MEK} besprochenen Kriterien erfüllt werden um eine robuste Umsetzung zu erreichen.\bigbreak


	In der Abbildung \ref{fig:BUM} wird der erste Schritt der \textit{Bottom Up} Migration angedeutet, indem die \textit{lib B} als erste auf den Modulpfad migriert wird. Diese hat keine Abhängigkeiten und ist der perfekte Kandidat für den initialen Schritt. Als Nächstes bietet sich die \textit{lib} Bibliothek für die Migration an, da sie keine weiteren Abhängigkeiten in den Klassenpfad besitzt. Jedoch ist es eine Drittanbieter Bibliothek und kann von uns nicht bearbeitet werden. Aufgrund dessen wird die \textit{lib C} für  den nächsten Migrationsschritt ausgewählt und als ein \textit{automatisches Modul} auf den Modulpfad migriert. Somit kann dieses die \textit{lib} und \textit{lib B} zugleich nutzen. Als Nächstes ist die \textit{lib A} an der reihe, dessen komplette Abhängigkeiten sich bereits auf dem Modulpfad Befinden. In der Konsequenz befinden sich alle Applikationsbibliotheken auf dem Modulpfad. \bigbreak

	Die \textit{Bottom Up} Migration bietet sich bei bereits aufgeteilten Applikationsarchitektur an, die über eine menge von \textit{Jar} Bibliotheken betrieben wird. Diese braucht weniger Aufwand um den Monolithen zu zerlegen und sind bereits über Schnittstellen mit einander Verbunden.  








