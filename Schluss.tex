\chapter{Gesamtevaluation}
Dieses Kapitel evaluiert die gesetzten Anforderungen aus der Anforderungsanalys, sowie der Anforderungsspezifikation und bewertet die Migration auf das Modulsystem von Java.\bigbreak

\section{Projektstruktur}
Für den Ersatz der veralteten Projektorganisation des Quellcodes wird die geforderte Projektstruktur in ein \textit{Maven} Standard Layout überführt, welches den Java Code von den \textit{JavaCC} Code trennt und die dazugehörigen Ressourcen separat verwaltet. Zusätzlich wurde die interne Struktur der Plugin Pakete, die sich mit anderen Plugins überschneiden, aufgelöst und umbenannt, um den Java Anforderung des Modulpfades zu entsprechen. Darüber hinaus wurde ein Modulname eingeführt, der nach der Java Konvention mit den Organisations- oder Applikationsdomäne beginnt, und mit dem Feature Namen endet. Der neue Modulname fasst den Quellcode eines Moduls zusammen und ermöglicht das Erstellen zusätzlicher Module innerhalb eines Plugins, die ein gemeinsames Ziel verfolgen. Des Weiteren spiegelt der Modulname die interne Paketstruktur wieder und gestaltet die Codebasis leserlich und verständlich. Hier können die Entwickler sofort ablesen, aus welchen Modulen die Klassen stammen und für welchen Zweck diese entwickelt worden sind.\newline
Der Aufwand für die Umstrukturierung war wie erwartet groß, denn die Modernisierung der internen Struktur eines Elements aus einem gekoppelten Verband, bringt für die Zugriffe auf dessen Ressourcen und Funktionen diverse Folgen mit sich. Demnach müssen alle Zugriffe auf das Plugin angepasst, die \textit{import} Angaben Plugin-Weit überarbeitet und die existierende Metainformation angeglichen werden. Infolgedessen wurden Änderungen nötig, die Plugin-Übergreifend aufgelöst werden müssen und über den Rahmen des Plugins hinausgehen. Dies führt zu Unsicherheit, da Änderungen in mehr als hundert Klassen entstehen und die Konsistenz der kompletten Applikation infrage stellt. \newline
Nichtsdestotrotz, ist die Umsetzung einer neuen Projektstruktur gelungen, und bringt Nachhaltigkeit und Beständigkeit mit sich.\bigbreak

\section{Migration}
Während der Modularisierung des ersten Prototyps, der die kontinuierliche Migration abdeckt, wurde der gemischte Betrieb von modularisiertem \textsc{Renew} Code mit dem Altsystem betrachtet. Dementsprechend sollte die Migration nicht nur Module bilden und das Ergebnis begutachten, sondern auch die fortlaufende Integrität mit dem Altsystem, inspizieren.\newline
Die Migration verfolgte den \textit{Chicken little} Ansatz und nutzte die von Java zur Verfügung gestellten Kommunikationsbrücke, die den Klassenpfad mit dem Modulpfad verbindet. Somit entstand kein zusätzlicher Aufwand für die manuelle Erstellung und die nachfolgende Qualitätskontrolle eines unentbehrlichen Elements. Da die Kommunikationsbrücke das Herzstück einer \textit{Chicken little} Migration umsetzt, ist die benannte Kommunikationsbrücke ein begehrenswertes und willkommenes Ausstattungsmerkmal des Modulsystems von Java, die einen großen Teil des Migrationsszenarios übernimmt. Dementsprechend musste im Laufe der Migration, nur auf die Adaption an die neue Umgebung geachtet werden, da die kontextübergreifende Kommunikation, sowie dessen Integrität bereits von Java zur Verfügung gestellt worden ist. \newline
Obwohl Java die Migration mit Migrationskonzepten unterstützt, entscheidet sie nicht, in welchen Ablauf der Code modularisiert werden soll. Daher wurden im Grundkapitel Konzepte vorgestellt, die nach der Größe einer Applikation Modularisierungsszenarien, empfehlen. Für die \textsc{Renew} Modularisierung wurde das \textit{bottom up} Verfahren ausgewählt, da dieses als das präferierte Verfahren für gekoppelte Bibliotheksstrukturen gilt, und sich gut auf das Plugin Konzept übertragen lässt. Das Verfahren modularisiert und integriert den Code, von den simplen bis zu den komplizierten Plugins, in das bestehende System, und gliedert zusätzlich die Drittanbieter Bibliotheken als automatische Module ein.\newline
Somit ist ein Verfahren erarbeitet worden, welches das Migrieren einer Applikation auf das Modulsystem von Java strukturiert und kontinuierlich durchführen kann.

\section{Modularisierung}
Auch wenn die bereits eingerichtete Projektstruktur und der Umsetzungsplan einen großen Teil der Modularisierung ausmachen, mussten die Plugins mit einer Schnittellenbeschreibung in Form einer \textit{module-info.java} ausgestattet werden, um als ein explizites Modul gelten zu dürfen. Das Anreichern der ersten Plugins mit einer Modulbeschreibung geschieht mühelos, da die Konfigurationsdatei eine schlichte Schnittstellenbeschreibung besitzt, die nur das Nötigste anfordert aber nur wenig anbietet. Jedoch mussten diese während der gesamten Migration durchgehend nachgepflegt werden, da für jedes nachträglichen Plugin, Pakete in bereits modularisierten Plugins geöffnet werden mussten. Somit entstand ein fortlaufender Arbeitsaufwand beim Überarbeiten von bereits deklarierten Schnittstellen in den benötigten Plugins.\newline
Ebenso wichtig ist die Adaption der Plugin Ressourcen, die von dem Modulsystem von Java gekapselt und für die Nutzung explizit in der \textit{module-info.java} geöffnet werden müssen. Diese Mechanik weist einen unerwarteten Effekt auf die Plugins auf, die aufeinander aufbauen, ähnliche Paketnamen für die Ressourcengliederung belegen und diese global wiederverwenden.\newline
Die Umsetzung des modularen Prototyps reorganisiert die Ressourcen und verlegt sie in das \textit{META-INF} Verzeichnis, welches keinen ausführbaren Code enthalten kann und in jedem Plugin existierend darf, ohne die eindeutig Paketeigenschaft zu verletzen. Somit ist es eine gute Wahl, um einen global einheitlichen Aufbau zu folgen. Die Umsetzung für die gestellte Anforderung benötigte mittleren Aufwand, da jedes Plugin eine eigene Vorgehensweise für das Laden der Ressourcen implementiert, und mit direkten \textit{String} Konstellationen, oder durch die Zusammensetzung der \textit{Path} Objekten, arbeitet. \newline
Dennoch erwies sich die Durchführung als vorbildhaft, denn die Abarbeitung der gesetzten Ziele und der entsprechenden Ausführungsschritte, ergaben einen makellosen Weg, vom bestehenden Alt-System auf das Modulsystem von Java.\bigbreak

Als Folge der Modularisierung der \textsc{Renew}-Plugins, inklusive der entsprechen Abhängigkeiten, entsteht eine Applikation mit einem globalen übersichtlichen Abhängigkeitsgraphen, der die Evaluation der gesamten Konstruktion ermöglicht. Die Betrachtung ergab eine große Anzahl an transitiven Abhängigkeiten, die mithilfe des \textit{transitive} Schlüssels innerhalb der \textit{module-info.java}, auf eine reduzierte Form des Abhängigkeitsgraphen heruntergebrochen werden konnte und ergab somit, eine alternative Sicht auf die Plugin Konstellation. Der neue Abhängigkeitsgraph illustriert eine natürliche Schichtenbildung von Plugins, die sich aus grundlegend bis zu erweiterten Fähigkeiten zusammensetzen. Darüber hinaus impliziert die transitive Deklaration der Abhängigkeiten ihre Delegation an Module, die dieses nutzen möchten. In der Konsequenz kann der gesamte Kontext eines Plugins auf Plugins, die dieses erweitern, weitergereicht werden. \newline
Angewandt an die \textsc{Renew}-Applikation, ist die transitive Deklaration der Modulabhängigkeiten eine großartige Ergänzung der Plugin-Architektur, denn ab diesen Zeitpunkt, wird der Kontext der zu erweiternden Plugins, an die aufbauenden Plugin unaufgefordert weitergereicht, ohne dass die aufbauenden Plugins sich um die globale Struktur und Abhängigkeitsverwaltung kümmern müssen. Dazu gehören die Plugin Grundlagen, Drittanbieter Bibliotheken und die entsprechende Versionierung.\bigbreak

Die \textit{module-info.java} erwirkt weitere Vorteile, die das Verwalten der Plugin-Module erleichtern. Dazu zählten native Java API's und Dienste, die die Administration der angebotenen Schnittstellen, die Auslese der angeforderten Module, die Feststellung des Modultyps, den Aufenthaltsort des Moduls sowie seinen Einstiegspunkt. In der Konsequenz, bietet die \textit{module-info.java} einen alternativen Informationsträger für den größten Teil der \textit{plugin.cfg} Inhalts. Dies entspricht den gesetzten Erwartungen des modularen Forschungsaspekts im \textsc{Renew} Kontext und eröffnet neue Umsetzungsmöglichkeiten des Plugin Managements.\newline
Um den Austausch der \textit{plugin.cfg} durchführen zu können, muss der \textsc{Renew} Plugin Manager modernisiert und auf die neue Konfigurationsdatei angepasst werden. Dementsprechend ist das Auslesen der benötigten Information und die neue Implementation, sowie die Interpretation der Plugin Organisation, ein zentrales Thema für den Übergang auf die native Java Konfigurationsdatei. Darüber hinaus ist das Konzept der Modulschichten eine anknüpfende Technik, die der Plugin-Manager in der Zukunft betreuen muss, um die Plugins, sowie die benötigten Drittanbieter-Bibliotheken auf die Modulschichten sachgemäß zu instanziieren.\newline
Obwohl die \textit{plugin.cfg} abgelöst werden kann, bleibt der Plugin-Manager das Herzstück von \textsc{Renew} und bedarf eines erheblichen Umstellungsaufwandes für den Umstieg auf die neu eingeführten Java Features.\bigbreak

\section{Modulschichten}
Die neue eingeführten Modulschichten bauen auf dem Modulkonzept auf, und adressieren gezielt die Administration der Java-Codebasis während der Laufzeit. Dafür wurden drei wichtige Verwaltungsobjekte eingeführt, nämlich der \textit{Modul-Sucher}, die \textit{Konfiguration} und die \textit{Modulschicht} selbst, die den Zustand der Applikation überwacht, validiert, und manipuliert (s. \ref{sec:module_layers}). Dementsprechend ist zu jedem Zeitpunkt bekannt, welche Module während des Betriebs involviert sind, ob das ergänzende Modul die Konsistenz der Applikation beeinträchtigt, und kann zusätzlich die Beziehungen zwischen den Modulen nach Belieben abwandeln. Im Kapitel \ref{ch:grRiss} wurden die Vorzüge der Modulschicht diskutiert und auf eine mögliche Plugin-Architektur abgebildet. Jedoch ist beim Erarbeiten des Grundriss-Prototyps, unerwartetes Verhalten festgestellt worden. Die \textit{automatischen} Module verhalten sich anders, als die \textit{expliziten} Module, und werden immer in den Modulgraph eingebunden, ohne diese auf Nutzung oder Anwendung zu prüfen. Darüber hinaus kann die \textit{transitive} Deklaration eines Moduls einen Konflikt aufbauen, wenn weitere Module dieselbe Bibliothek an die übergeordnete Modulschicht weiterleiten. Somit ist die \textit{transitive} Weiterleitung explizit und informiert jeden Nutzer des Moduls über die Existenz der Bibliothek.\newline
Die Umsetzung des Grundriss-Prototyps beinhaltet keine dynamische Zusammensetzung der Module, diese müssen wie zuvor von dem Plugin-Manager organisiert und verwaltet werden. Dennoch kann das Modulsystem von Java mithilfe des Modulgraphen eine zusammenhängende Übersicht auf alle Plugins geben, die zum Start der Applikation zur Verfügung stehen. Somit könnte der Plugin-Manager den Modulgraphen für die Erstellung der Modulschichten nutzen, indem die Plugins laut der Modulordnung, aus dem Modulgraph abgelesen und dementsprechend instanziiert werden. Die Herausforderung der Umsetzung liegt in der Verwaltung der Drittanbieter-Bibliotheken, die mit dem entsprechenden Plugin in einer Schicht zusammengefasst werden müssen, damit die angeforderten Drittanbieter-Bibliotheken mit dem Plugin zusammen geladen und entladen werden können. Da die Umsetzung den Rahmen dieser Arbeit überschreitet, konnte der Plugin-Manager nicht detailliert untersucht und angepasst werden. \newline 
Dennoch ist die Umsetzung des Grundriss-Prototyps vielversprechend und kann das lang gewünschte dynamische Laden und Entladen der Module realisieren. \bigbreak

\section{Konstruktionsumgebung}
\textit{Gradle} ist ein Code Verwaltungswerkzeug, welches sich auf flexible Konfiguration spezialisiert und im Gegenteil zu \textit{Maven}, die vorgesetzte Struktur flexibel anpassen lässt. Die Flexibilität ist ein Schlüsselkriterium für das Plugin Verband von \textsc{Renew}, da die Plugins in ihrer Auswahl der Technologie, Konfiguration und Aufbereitung der Funktionalität, nicht eingeschränkt werden dürfen. Somit sollte jedes Plugin ein gängiges Rahmenwerk für die Verarbeitung enthalten, welches an die Bedürfnisse jedes einzelnen Plugins erweitert und angepasst werden kann. Zuvor hat \textit{Ant} die benötigte Flexibilität geboten, wurde jedoch mit der Zeit groß, komplex und unübersichtlich. Aus den genannten Gründen wurde \textit{Ant} ersetzt und durch das \textit{Gradle} Werkzeug ausgetauscht.\newline
Der Umstieg von \textit{Ant} auf \textit{Gradle} erforderte einen respektablen Aufwand, da man weitgreifende \textit{Ant} Fachkenntnisse benötigt und von der dürftigen \textit{Ant} Konvention wenig Unterstützung bekommt. Darüber hinaus muss das \textit{Gradle} Fachwissen vorhanden sein oder erarbeitet werden, um den Übergang einleiten zu können. Somit muss eine Disziplin, nämlich das Bauen einer Applikation, doppelt angeeignet werden und kann folglich nicht jeden Mitarbeiter oder Studierenden für die Umsetzung überzeugen. Dennoch ist der Vorteil einer Migrantin auf \textit{Gradle} enorm und bringt auf lange Sicht, ein einfaches, sauberes, wartbares und langlebiges Ergebnis. \bigbreak

Durch die Einführung von \textit{Gradle}, hat sich der integrierte Lebenszyklus sofort bemerkbar gemacht und ließ ein globales Gerüst für das Erstellen aller Plugins an Ort und Stelle anfertigen. Dazu zählt das Abbilden der Projektstruktur, das Konfigurieren der fundamentalen Ausführungsschritte wie \textit{compileJava} und \textit{Jar}. Darüber hinaus konnten \textsc{Renew} bezogenen Ausführungsschritte an Ort und Stelle integriert und auf alle Plugins übertragen werden. Somit konnten Plugins die bereitgestellte Umgebung weiter verfeinern, und mit individuell relevanten Aufgaben erweitern. Der genannte Aufbau hat einen positiven Einfluss auf die Lesbarkeit und den Aufwand für das Nachvollziehen der Plugins, sodass neu eingeführten Plugins durch keine, oder nur notwendige Ausführungssehritte erweitert werden müssen, ohne die komplette Umgehung in Betracht zu ziehen. Des Weiteren kann die erstellte Umgebung auf \textit{Mulan} übertragen werden und integriert sich gut in die Entwicklungsumgebung des TGI/ART Forschungsbereichs.\newline
Dennoch sind bei der Umsetzung unerwartete Ereignisse aufgetreten. Zum Beispiel die Nutzung von \textit{JavaCC}, die das Einbinden eines \textit{Gradle}-Plugins benötigt und in den \textit{Gradle}-Lebenszyklus an der passenden Stelle eingebettet werden musste, um den Java-Code vor dem Kompilieren zu generieren. Darüber hinaus benutzt eine große Plugin Anzahl von \textsc{Renew} selbst erstellten \textit{Ant}-Ausführungsschritte, die verbindlich durchgeführt werden müssen, um alle notwendigen Java Klassen, sowie Ressourcen, die während der Laufzeit benötigt werden, zu erstellen. Dazu zählt der \textit{CreateShadownets}, sowie der \textit{GenerateFSOntology} Ausführungsschritt, die vor dem Kompilieren des entsprechenden Plugins, durchgeführt werden müssen. Die \textit{Gradle}-Umgebung integriert in sich eine \textit{Ant}-Instanz und lässt die beiden \textit{Ant-Tasks} aus \textit{Gradle} ausführen und in den Lebenszyklus integrieren. Somit war die Unterstützung von \textit{Gradle} beim Überführen der Build-Umgebung, ein gut durchdachtes und willkommenes Leistungsmerkmal.

\chapter{Schluss}

\section{Zusammenfassung}

Das Grundlagenkapitel behandelt das Arbeiten mit dem Klassenpfad auf der virtuellen Maschine von Java. Dazu gehören Konzepte, wie der \textit{Classpath} und der \textit{Klassenlader}, sowie \textit{Reflexion} und die \textit{Interfaces}, die in der Umsetzung von \textsc{Renew} eine wichtige Rolle spielen. Dementsprechend werden Mechanismen vorgestellt, wie das Auffinden der Klassenaufenthaltsorte, das sichere Laden in die Virtuelle Maschine und das Arbeiten mit unbekannten Klassentypen.\bigbreak

In dem Kapitel der Modularisierung wurden wichtige Konzepte und Eigenschaften der Modularisierung erarbeitet, die in der Zukunft helfen sollen, Module sauber zu entwerfen, zu erstellen oder zu bewerten. Dazu gehören kritische Modul Charakteristika, wie Modulkopplung, Modulbindung, Seiteneffektfreiheit, Modulgröße und Namensräume. \bigbreak

Mithilfe des Migrationskapitels werden zwei wesentliche Vorgehensweisen dargestellt, mit denen eine Migration durchgeführt werden kann. Zusätzlich wird auf das Modulsystem von Java eingegangen, das eine bestimmte Vorstellung von einer kontinuierlichen Migration auf das Modulsystem besitzt. \newline
Die Migration des \textsc{Renew} Prototypen bedient sich dieser Idee und modularisiert die Plugins entsprechend dem \textit{bottom up} Ansatzes. Darüber hinaus wurden wesentliche Modulsystem Migrationshürden benannt, welche die essenziellen Probleme zusammenfassen. \bigbreak

Das Kapitel der Analyse und Ausgangssituation, vermittelt die Zielsetzung und den Umfang der Abschlussarbeit, sowie die nachfolgende Durchführung. Es werden Gründe für eine Migration auf das Modulsystem von Java zusammengetragen, die daraus resultierenden Konsequenzen analysiert, und anschließend die Anforderungen an die bevorstehenden Prototypen behandelt. Zum Schluss wird ein aktueller Zustand von \textsc{Renew}, \textsc{Mulan}, sowie der Umsetzung des Plugin-Systems konstruiert, die im Nachfolgenden mit einem Umsetzungsplan die gesetzte Spezifikation, erreichen sollen.\bigbreak

Im Kapitel des modularen \textsc{Renew} Prototypen, geht es um die Migration von \textsc{Renew} auf das Modulsystem von Java, die eine kontinuierliche und beispielhafte Migration demonstriert. Diese beinhaltet einen Umsetzungsplan, der die Projektstruktur reorganisiert, das \textit{Gradle}-Werkzeug für die Organisation des Projekts einführt und anschließend das Modulsystem von Java auf die vorbereitete Codebasis aufsetzt. Zum Schluss folgt eine Evaluation, die den Prototypen auf das Modulsystem von Java optimal abstimmt und Parallelen mit dem \textit{Gradle}-Werkzeug zieht.\bigbreak

Das Kapitel des \textsc{Mulan} Prototypen demonstriert mögliche Schwierigkeiten und den betreffenden Aufwand, der mit dem Austausch einer grundlegenden Basis-Software in einem größeren System auftreten könnte. Da das Rahmenwerk \textsc{Mulan} auf dem \textsc{Renew} Simulator aufsetzt und ohne diesen nicht betriebsfähig ist, ist \textsc{Mulan} komplett an \textsc{Renew} während der Kompilation, sowie der Laufzeit angewiesen. Daraus folgen Referenz- und Zugriffsschwierigkeiten, die global behoben werden müssen. Zusätzlich wird mit diesen Prototypen ein Übergangsszenario simuliert, das \textsc{Renew} mit dem \textit{Gradle}-Werkzeug und \textsc{Mulan} mit dem \textit{Ant}-Werkzeug zugleich ein funktionierendes Ergebnis liefern. \bigbreak

In dem Kapitel des \textit{Grundriss}-Prototyps wurde eine mögliche Umsetzung der Plugin-Architektur mithilfe der Modulschichten angefertigt. Der Prototyp demonstriert die verzweigte Modul- und Klassensuche und löst damit ein grundlegendes Hindernis der bestehenden Plugin-Verwaltung von \textsc{Renew}. Des Weiteren wurde das \textit{Service-Lader} Konzept untersucht, um das Einbinden und Austauschen von Plugins während der Laufzeit zu ermöglichen. Die Umsetzung hat sich als betriebsfähig erwiesen und konnte die gestellte Anforderung erfüllen. Jedoch wurde an manchen Stellen unerwartetes Verhalten wahrgenommen, welches bei der nächsten Umsetzung miteinkalkuliertt werden muss. \bigbreak

Zum Schluss wird das Ergebnis der Abschlussarbeit evaluiert, zusammengefasst und der Ausblick für die mögliche Forschung und Ausbau der Prototypen gegeben. 


\section{Ausblick} 
	Mit dieser Arbeit wurde das Modulsystem von Java in die \textsc{Renew} Applikation integriert, organisiert und erforscht. Die Ergebnisse deuten auf eine Aufwertung der Plugin-Eigenschaften, mühelose Projektverwaltung, sowie neue Möglichkeiten für die Umsetzung des Plugin-Managements. Dennoch konnten nicht alle auftretenden Fragen an Ort und Stelle geklärt werden.\bigbreak
	Im Folgenden werden offene Fragestellungen gelistet, die für Konsistenz, Erweiterbarkeit und die Fortentwicklung von \textsc{Renew} relevant sind.  
	
 \subsection*{Migration der Plugins}
	\textsc{Renew} besteht aus einer großen Plugin Anzahl, die zu einem gewissen Grad miteinander verzahnt ist. Das  Zusammenfügen der Plugins geschieht mit verschiedenen Verfahren, zu unterschiedlichen Zeitphasen und an diversen Stellen. Somit ist die Modularisierung und das Erstellen der \textsc{Renew} Plugin-Basis keine triviale Aufgabe und benötigt mehr Zeit, als zuerst angenommen. Aus diesem Grund konnten nicht alle \textsc{Renew} Plugins in das Modulsystem überführt werden und müssen in der Zukunft nachgepflegt werden. 

 \subsection*{Mulan Integration}
	Der \textsc{Mulan} Prototyp bestätigt den parallelen Betrieb von modularen, sowie nicht modularem Code-Bausteinen. Nichtsdestotrotz muss die Agentenplattform in Zukunft auf das Modulsystem von Java migriert werden und kann von der \textsc{Renew} Umsetzung profitieren.\newline
	Die \textsc{Mulan} Agenten Plattform orientiert sich an \textsc{Renew} und baut auf demselben Plugin Konzept auf. Dies ermöglicht den Plugin Manager die \textsc{Renew}, sowie die \textsc{Mulan} Plugins zugleich zu verwalten. Daraus folgt eine strukturelle Ähnlichkeit, die mit dem Modulsystem von Java und \textit{Gradle} ausgenutzt werden kann, indem dieselbe Projektstruktur aufgesetzt und von \textit{Gradle} in den \textsc{Renew} Kontext für das Kompilieren mit aufgenommen wird.\newline
	Dafür muss die Projektstruktur der \textsc{Mulan} Plugins an die \textsc{Renew} Umsetzung angeglichen, und zusätzlich durch eine \textit{build.gradle} Konfigurationsdatei erweitert werden. Somit kann \textit{Gradle} die globale Konfiguration an alle \textsc{Mulan} Plugins delegieren und jedes \textsc{Mulan} Plugin durch eine individuelle Konfiguration herrichten. 
		
 \subsection*{Abhängigkeitsmanagement}
	Eine wichtige mitgelieferte Fähigkeit von \textit{Gradle} ist die Abhängigkeitsverwaltung, die uns mit der passenden Bibliothek und der passenden Version aus dem Web versorgt. Die Abhängigkeitsverwaltung wurde mit den ersten Prototypen in \textsc{Renew} nur zum Teil integriert, da einige Drittanbieter-Bibliotheken speziell an \textsc{Renew} angepasst wurden und nicht mehr aus dem globalen \textit{Maven-Repository} heruntergeladen werden können. Dementsprechend werden die modifizierten Bibliotheken aus dem lokalen Verzeichnis und alle Anderen aus dem Web referenziert.\newline
	Für die saubere Umsetzung der Abhängigkeitsverwaltung, müssen die modifizierten Bibliotheken von dem Arbeitsbereich gehosted werden, um die Bandbreite der Internetverbindung zu entlasten und ein schnelles Auschecken des Projekts zu ermöglichen. 	
	
 \subsection*{Rückwärts Kompatibilität}
	Das Problem der \textit{Split Packages} ist in \textsc{Renew} weit verbreitet. Durch die Reorganisation der gesplitteten Pakete, ändert sich der Paketname der Klassen, die an vielen Stellen im Code mit einem direkten Verweis genutzt werden. Obwohl die Klassenverweise gepflegt wurden, können bereits erstellte oder generierte Ressourcen auf der lokalen Maschine des Nutzers, wie zum Beispiel die \textsc{Renew} Netze Zeichnungen, nicht korrekt angezeigt werden, da diese auf den veralteten voll-qualifizierten Klassennamen referenzieren.\newline
	Für die valide Darstellung der \textit{legacy} Zeichnungen, benötigt \textsc{Renew} eine Transferfunktion, die Ressourcen nach funktionsuntüchtigen Klassen abtastet und diese vor dem Öffnen substituiert.
	
 \subsection*{Migration der Ant Ausführungsschritte}
	Die Umsetzung des BPMN Plugins beinhaltet die Aufnahme der benötigten \textit{Ant}-Ausführungsschritte in die neue \textit{Gradle-Build}-Umgebung, welche Klassen und Ressourcen für den Betrieb generieren. Dank der nahtlosen Integration von \textit{Ant} in \textit{Gradle}, war es möglich, die Ausführungsschritte mit minimalem Aufwand aus \textit{Gradle} aufzurufen und die Funktionalität nahtlos in die Produktion der Bibliothek einzubinden. Jedoch wird der Aufruf über eine von \textit{Gradle} zur Verfügung gestellte \textit{Ant}-Instanz durchgeführt, welche die Arbeitsweise von \textit{Ant} voraussetzt. Somit muss \textit{Renew} Entwickler zwei Disziplinen beherrschen, die sich im selben Kontext befinden.\newline
	Die \textit{Ant}-Ausführungsschritte können im \textit{Groovy}, \textit{Java} oder \textit{Kotlin} Format als \textit{Gradle Tasks} umgesetzt werden, um die Prozedur ohne Einschränkungen, zusätzlichen Aufwand und \textit{Ant} Kenntnisse betreiben zu können. 
	
 \subsection*{Zerlegung der Plugins}
	Dank der Injektion der Moduleigenschaften in Plugins, können die Plugins in das Modulsystem von Java aufgenommen werden und verfügen nun über erweiterte Dienste, die das Verwalten und Validieren der Code-Bausteine automatisch übernehmen. In der Konsequenz ermöglichen die eingeführten Änderungen den Betrieb der Plugins auf dem Modulpfad, die nun auf alle neuen Features des Modulsystems zugreifen können. Dennoch können Plugins ihre Moduleigenschaften weiter schärfen, um die Idee der Modularisierung weiterzuverfolgen. \newline
	Einer der zentralen Eigenschaften der Module ist ihre Größe, die einen klaren übersichtlichen Aufgabenbereich abdeckt und leicht verstanden, sowie ausgetauscht werden kann. Diese Eigenschaft wird nicht von jedem Plugin-Modul umgesetzt, da bestimmte Plugins komplexe Aufgaben lösen und die komplette Verarbeitungskette intern umsetzt. Somit führt die Weiterentwicklung der Plugins zu großen und übersichtlichen Komponenten, die komplexe Aufgaben lösen und die Verarbeitungskette der Teilaufgaben unübersichtlich arrangieren, sodass die Logik nur schwer zu überblickbar ist. Denn nicht jedes Detail kann sofort wahrgenommen und in der globalen Umsetzung richtig interpretiert werden.\newline
	Um die Verarbeitungsschritte in einem größeren Plugin voneinander zu differenzieren, müssen Plugins, die bereits als ein ganzes einzelnes Modul umgesetzt worden sind, in kleinere Aufgabenbereiche aufgeteilt und in Moduleinheiten zerlegt werden. Infolgedessen entstehen gekapselte Verarbeitungsschritte, die separat verstanden, sowie ausgetauscht werden können und bringen damit  \textit{Renew} ein Schritt näher zu einer erstrebenswerten Perspektive der perfekten Umsetzung eines modularen Systems. \newline
	Die Aufteilung der großen Plugins in kleinere Moduleinheiten, ist eine individuelle und zeitintensive Aufgabe, die ein tiefgründiges und konzeptionelles Verständnis des Plugins erfordert. Denn nicht jede mögliche Aufteilung der Code-Blöcke, garantiert die Korrektheit der Plugins in ihrer neuen Form. \newline
	In der Konsequenz konnte diese Abschlussarbeit die Aufgabe nicht umsetzen. Trotzdem bleibt die Aufteilung der Plugins in kleine beherrschbare Module eine grundlegende Herausforderung, die in der Zukunft thematisiert werden muss. 

 \subsection*{Fortentwicklung des Plugin Managements}
	Die momentane Umsetzung von \textsc{Renew} basiert auf einem Klassenlader-System, welches das Entladend der Plugin nicht erlaubt. In der Konsequenz bleiben die Klassen auf dem Klassenpfad, sind immer erreichbar und können nicht aktualisiert werden. Für das geschilderte Problem wurde ein Lösungsansatz \ref{sec:pm} vorgestellt, welcher auf dem Modulsystem von Java aufbaut und eine mögliche Umsetzung für den dynamischen Lademechanismus abbildet. Der vorgestellte Grundriss demonstriert, wie die Plugins separat über Modulschichten verteilt und verwaltet werden können.\newline
	Für die Integration des Grundrisses in das Plugin Management, muss der Plugin Manager eine neue Aufgabe übernehmen, nämlich die Aufteilung der Plugins auf die Modulschichten mit den dazugehörigen Drittanbieter Bibliotheken. Ebenso die Verknüpfung der Modulschichten untereinander, und das Laden und Entladen von bestehender oder neu hinzugekommener Plugin Schichten. Darüber hinaus müssen für die UI optionale Plugins mit dem \textit{Service-Lader} von Java erstellt und verknüpft werden, sodass die UI für sie unbekannte Plugins manipulieren kann. \newline
	Die Aufgabe beschäftigt sich mit der Umsetzung lang gewünschten Verhaltens, welches nun mit Java ohne zusätzlichen Drittanbieter-Rahmenwerks angegangen werden kann. 


% Was wollte ich erreichen 
% Unterziele 
% Bewertung der Unterziehle 
% Maln Zyclus 
% Was habe ich erreicht 


