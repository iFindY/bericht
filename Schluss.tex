\chapter{Gesamt Evaluation}
Dieses Kapitel evaluiert die gesetzten Anforderungen aus der Anforderungsanalyse sowie der Anforderungsspezifikation und bewertet die Migration auf das Modulsystem von Java.\bigbreak	

Für den Ersatz der veralteten Projektorganisation des Quellcodes wird die geforderte Projektstruktur in ein Maven Standard Layout überführt, welches den Java Code von den Java Compiler-Compiler Code trennt und die dazugehörigen Ressourcen separat verwaltet. Zusätzlich wurden die interne Struktur der Plugin Pakete, die sich mit anderen Plugins überschneiden aufgelöst und umbenannt, um den Java Anforderung des Modulpfades zu entsprechen. Darüber hinaus wurde ein Modulname eingeführt, der nach der Java Konvention mit den Organisations- oder Applikationsdomäne beginnt und mit den Feature Namen endet. Der neue Modulname fasst den Quellcode eines Moduls zusammen und ermöglicht das Erstellen zusätzlicher Module innerhalb eines Plugins, die ein gemeinsames Ziel verfolgen. Des Weiteren spiegelt der Modulname die interne Paketstruktur wieder und gestaltet die Codebasis Leserlich und Verständlich, da die Entwickler sofort ablesen können, aus welchen Modulen die Klassen stammen und für welchen Zweck diese entwickelt worden sind.\newline
Der Aufwand für die Umstrukturierung war wie erwartet groß, denn die Modernisierung der internen Struktur eines Elements aus einem gekoppelten Verband diverse Folgen für die Zugriffe auf dessen Ressourcen und Funktionalität mit sich bringt. Demnach müssen alle Zugriffe auf das Plugin angepasst, die \textit{import} Angaben Plugin-Weit überarbeitet und die existierende Meta-Information angeglichen werden. In Folge dessen wurden Änderungen nötig, die Plugin-Übergreifend aufgelöst werden müssen und über den Rahmen des Plugins hinausgehen. Dies führt zu Unsicherheit, da Änderungen in mehre als hundert Klassen entstehen und die Konsistenz der kompletten Applikation in Frage stellt. \newline
Im Endeffekt, ist die Umsetzung einer neuen Projektstruktur in einer ausgereiften Applikation eine wichtige und verantwortungsvolle Aufgabe, die  Nachhaltigkeit und Beständigkeit mit sich bringt.\bigbreak    

Während der Modularisierung des ersten Prototypen, der die kontinuierliche Migration abdeckt, wurde der gemischte Betrieb von modularisiertem \textsc{Renew} Code mit dem alt System betrachtet. Dementsprechend sollte die Migration nicht nur Module bilden und das Ergebnis begutachten, sondern auch die fortlaufende Integrität mit dem Altsystem inspizieren.\newline
Die Migration verfolgte den \textit{Chicken little} Ansatz und nutzte die von Java zur Verfügung gestellten Kommunikationsbrücke, die den Klassenpfad mit dem Modulpfad verbindet. Somit entstand kein zusätzlicher Aufwand für die manuelle Erstellung und die nachfolgende Qualitätskontrolle eines unentbehrlichen Elements. Da die Kommunikationsbrücke das Herzstück einer \textit{Chicken littel} Migration umsetzt, ist die benannte Kommunikationsbrücke ein begehrenswertes und willkommenes Ausstattungsmerkmal des Modulsystems von Java, die einen großen Teil des Migrationsszenarios übernimmt. Dementsprechend musste im Laufe der Migration nur auf die Adaption an die neue Umgebung geachtet werden, da die Kontext übergreifende Kommunikation sowie dessen Integrität bereits von Java zur Verfügung gestellt worden ist. \newline
Obwohl Java die Migration mit Migrationskonzepten unterstützt, entscheidet sie nicht in welchen Ablauf der Code Modularisiert werden soll. Daher wurden im Grundkapitel Konzepte vorgestellt, die nach der Größe einer Applikation Modularisierungsszenarien empfehlen. Für die \textsc{Renew} Modularisierung wurde das \textit{bottom up} Verfahren ausgewählt, da dieses als das präferierte Verfahren für gekoppelte Bibliotheksstrukturen gilt und sich gut auf das Plugin Konzept übertragen lässt. Das Verfahren modularisiert und integriert den Code, von den simplen bis zu den komplizierten Plugins, in das bestehende System und gliedert zusätzlich die Drittanbieter Bibliotheken als automatische Module ein.\newline 
Obwohl die bereits eingerichtete Projektstruktur und der Umsetzungsplan einen großen Teil der Modularisierung ausmachen, mussten die Plugins mit einer Schnittellenbeschreibung in Form einer \textit{module-info.java} ausgestattet werden, um als ein explizites Module gelten zu dürfen. Das Anreichern der ersten Plugins mit einer Modulbeschreibung geschieht mühelos, da die Konfigurationsdatei eine schlichte Schnittstellenbeschreibung besitzt, die nur das nötigste anfordert und nur wenig anbietet. Jedoch mussten diese während der gesamten Migration durchgehend nach gepflegt werden, da für jedes nachträglichen Plugin, Pakete in bereits modularisierten Plugin geöffnet werden mussten. Somit entstand ein fortlaufender Arbeitsaufwand beim Überarbeiten von bereits deklarierten Schnittstellen in den benötigten Plugins.\newline
Nichtsdestotrotz erwies sich die Durchführung als Vorbildhaft, denn die Abarbeitung der gesetzten Ziele und der entsprechenden Ausführungsschritte ergaben einen makellosen Weg vom bestehenden Altsystem auf das modernen Modulsystem von Java.\bigbreak

Als Konsequenz der Modularisierung von \textsc{Renew} samt der entsprechen Abhängigkeiten entsteht eine Applikation mit einem globalen übersichtlichen Abhängigkeitsgraphen, der die Evaluation der gesamten Konstruktion ermöglicht. Die Betrachtung ergab eine große Anzahl an transitiven Abhängigkeiten, die mithilfe des \textit{trantiv} Schlüssel auf eine reduziert Form des Abhängigkeitsgraphen runter gebrochen werden konnten und ergaben somit eine alternative Sicht auf die Plugin Konstellation. Der neue Abhängigkeitsgraph illustrierte eine natürliche Schichtenbildung von Plugins, die sich aus grundlegend bis zu erweiterten Fähigkeiten zusammensetzen. Des Weiteren impliziert die transitive Deklaration der Abhängigkeiten ihre Delegation an Module die dieses Nutzen möchten. In der Konsequenz kann der gesamte Kontext eines Plugins auf Plugins, die dieses erweitern, weitergereicht werden. \newline
Angelwand an die \textsc{Renew} Applikation, ist die transitive Deklaration der Modulabhängigkeiten eine großartige Erweiterung der Plugin Architektur, denn ab diesen Zeitpunkt wird der Kontext der zu erweiternden Plugins an den aufbauenden Plugin \textit{automatisch} weitergereicht, ohne dass die aufbauenden Plugins sich um die globale Struktur und Abhängigkeitsverwaltung kümmern müssen. Dazu gehören die Plugin Grundlagen, Drittanbieter Bibliotheken sowie die entsprechende Versionierung. \newline



\chapter{Schluss}


\section{Zusammenfassung}

Das Grundlagenkapitel behandelt das Arbeiten mit dem Klassenpfad auf der virtuellen Maschine von Java. Dazu gehören Konzepte wie der \textit{Classpath} und der \textit{Klassenlader} sowie \textit{Reflektion} und die \textit{Interfaces}, die in der Umsetzung von \textsc{Renew} eine wichtige Rolle spielen. Dementsprechend werden Mechanismen vorgestellten, wie das Auffinden der Klassenaufenthaltsorte, das sichere Laden in die Virtuelle Maschine und das Arbeiten mit unbekannten Klassentypen.\bigbreak

In dem Kapitel der Modularisierung wurden wichtige Konzepte und Eigenschaften der Modularisierung erarbeitet, die in der Zukunft helfen sollen, Module sauber zu entwerfen, zu erstellen oder zu bewerten. Dazu gehören kritische Modul Charakteristika, wie Modulkopplung, Modulbindung, Seiteneffektfreiheit, Modulgröße und Namensräume. \bigbreak

Mithilfe des Migrationskapitels werden zwei wesentliche Vorgehensweisen dargestellt, mit den eine Migration durchgeführt werden kann. Zusätzlich wird auf das Modulsystem von Java eingegangen, das eine bestimmte Vorstellung von einer Kontinuierlichen Migration auf das Modulsystem besitzt. \newline
Die Migration des \textsc{Renew} Prototypen bediene sich dieser Idee und modularisiert die Plugins entsprechend dem \textit{bottom Up} Ansatzes. Darüber hinaus wurden wesentliche Modulsystem Migrationshürden benannt, welche die essenziellen Probleme zusammenfassen. \bigbreak

Das Kapitel der Analyse und Ausgangssituation vermittelt die Zielsetzung und den Umfang der Abschlussarbeit sowie die nachfolgende Durchführung. Es werden Gründe für eine Migration auf das Modulsystem von Java zusammengetragen, die daraus resultierenden Konsequenzen analysiert und anschließend die Anforderung an die bevorstehenden Prototypen behandelt. Zum Schluss wird ein aktueller Zustand der \textsc{Renew} sowie \textsc{Mulan} Software konstruiert, die im Nachfolgenden mit einem Umsetzungsplan die gesetzte Spezifikation erreichen sollen.\bigbreak

In dem Kapitel des modularen \textsc{Renew} Prototypen geht es um die Migration von \textsc{Renew} auf das Modulsystem von Java, die eine kontinuierliche und beispielhafte Migration demonstriert. Diese beinhaltet einen Umsetzungsplan, der die Projektstruktur reorganisiert, das Gradle Werkzeug für die Organisation des Projekts einführt und anschließend das Modulsystem von Java auf die vorbereitete Code-Basis aufsetzt. Zum Schluss folgt eine Evaluation, die den Prototypen auf das Modulsystem von Java optimal abstimmt und Parallelen mit dem Gradle Werkzeug zieht.\bigbreak

 Das Kapitel des \textsc{Mulan} Prototypen demonstriert mögliche Schwierigkeiten und den betreffenden Aufwand, der mit dem Austausch einer grundlegend Basis-Software in einem größeren System auftreten könnte. Da das Rahmenwerk \textsc{Mulan} auf dem \textsc{Renew} Simulator aufsetzt und ohne diesen nicht betriebsfähig ist, ist \textsc{Mulan} komplett an \textsc{Renew} während der Kompilation sowie der Laufzeit angewiesen. Daraus folgen Referenz- und Zugriffsschwierigkeiten, die global behoben werden müssen. Zusätzlich wird mit diesen Prototypen eine Übergangsszenario simuliert, das \textsc{Renew} mit dem Gradle Werkzeug und \textsc{Mulan} mit dem Ant Werkzeug zugleich ein funktionierendes Ergebnis liefern. \bigbreak

 Zum Schluss wird das Ergebnis der Abschlussarbeit evaluiert, zusammengefasst und der Ausblick für die mögliche Forschung und Ausbau der Prototypen gegeben. 


\section{Ausblick} 

	Mit dieser Arbeit wurde das Modulsystem von Java in die \textsc{Renew} Applikation integriert, organisiert und erforscht. Die Ergebnisse deuten auf eine Aufwertung der Plugin-Eigenschaften, mühelose Projektverwaltung sowie neue Möglichkeiten für die Umsetzung des Plugin-Managements. Dennoch konnten nicht alle auftretenden Fragen an Ort und Stelle geklärt werden.\bigbreak
	Im Folgenden werden offene Fragestellungen gelistet, die für Konsistenz, Erweiterbarkeit und die Fortentwicklung von \textsc{Renew} relevant sind. 
	
 \subsubsection{Migration der Plugins}
	\textsc{Renew} besteht aus einer großen Plugin Anzahl, die zu einem gewissen Grad mit einander verzahnt ist. Das  Zusammenfügen der Plugins geschieht mit verschiedenen Verfahren, zu unterschiedlichen Zeitphasen und an diversen Stellen. Somit ist die Modularisierung und das Erstellen der \textsc{Renew} Plugin-Basis keine triviale Aufgabe und benötigt mehr Zeit als zuerst angenommen. Aus diesem Grund konnten nicht alle \textsc{Renew} Plugins in das Modulsystem überführt werden und müssen in der Zukunft nachgepflegt werden. 

 \subsubsection{Integration der Mulan Plugins}
	Der \textsc{Mulan} Prototyp bestätigt den parallelen Betrieb von modularen sowie nicht modularem Code-Bausteinen. Nichtsdestotrotz muss die Agentenplattform in der Zukunft auf das Modulsystem von Java migriert werden und kann von der \textsc{Renew} Umsetzung profitieren.\newline 
	Die \textsc{Mulan} Agenten Plattform orientiert sich an \textsc{Renew} und baut auf dem selben Plugin Konzept auf. Dies ermöglicht den Plugin Manager die \textsc{Renew} sowie die \textsc{Mulan} Plugins zu gleich zu verwalten. Daraus folgt eine strukturelle Ähnlichkeit, die mit dem Modulsystem von Java und Gradle ausgenutzt werden kann, indem dieselbe Projektstruktur aufgesetzt und von Gradle in den \textsc{Renew} Kontext für das Kompilieren mit aufgenommen wird.\newline
	Dafür muss die Projektstruktur der \textsc{Mulan} Plugins an die \textsc{Renew} Umsetzung angeglichen und zusätzlich durch eine \textit{build.gradle} Konfigurationsdatei erweitert werden. Somit kann Gradle die globale Konfiguration an alle \textsc{Mulan} Plugins delegieren und jedes \textsc{Mulan} Plugin durch eine individuelle Konfigurationen individuell herrichten. 
		
 \subsubsection{Abhängigkeitsmanagement}
	Eine wichtige mitgelieferte Fähigkeit von Gradle, ist die Abhängigkeitsverwaltung, die uns mit der passenden Bibliothek und der passenden Version aus dem Web versorgt. Die Abhängigkeitsverwaltung wurde mit den ersten Prototypen in \textsc{Renew} nur zum Teil integriert, da einige Drittanbieter Bibliotheken speziell an \textsc{Renew} angepasst wurden und nicht mehr aus dem globalen Maven-Repository heruntergeladen werden können. Dementsprechend werden die modifizierten Bibliotheken aus dem lokalen Verzeichnis und alle anderen aus dem Web referenziert.\newline
	Für die saubere Umsetzung der Abhängigkeitsverwaltung, müssen die modifizierten Bibliotheken von dem Arbeitsbereich gehosted werden, um das Bandbreite der Internetverbindung zu entlasten und eine schnelles Auschecken des Projekts zu ermöglichen. 	
	
 \subsubsection{Rückwärts Kompatibilität}
	Das Problem der \textit{Split Packages} ist in \textsc{Renew} weit verbreitet. Durch die Reorganisation der gesplitteten Pakete ändert sich der Paketname der Klassen, die an vielen Stellen im Code mit einem direkten Verwies genutzt werden. Obwohl die Klassen Verweise gepflegt wurden, können bereits erstellte oder generierte Ressourcen auf der lokalen Maschine des Nutzers, wie zum Beispiel die \textsc{Renew} Netze Zeichnungen, nicht korrekt angezeigt werden, da diese auf den veralteten voll-qualifizierten Klassennamen referenzieren.\newline
	Für die valide Darstellung der \textit{legacy} Zeichnungen, benötigt \textsc{Renew} eine Transferfunktion, die Ressourcen nach funktionsuntüchtigen Klassen abtastet und diese vor dem Öffnen substituiert.
	
 \subsubsection{Migration der Ant Tasks}
	Die Umsetzung des BPMN Plugins beinhaltet die Aufnahme der benötigten Ant Ausführungsschritte in die neue Gradle Build-Umgebung, die Klassen und Ressourcen für den Betrieb generieren. Dank der nahtlosen Integration von Ant in Gradle, war es möglich die Ausführungsschritte mit minimalen Aufwand aus Gradle aufzurufen und die Funktionalität nahtlos in die Produktion der Bibliothek einzubinden. Jedoch wird der Aufruf über eine von Gradle zur Verfügung gestellte Ant Instanz durchgeführt, welche die Arbeitsweise von Ant voraussetzt. Somit muss \textit{Renew} Entwickler zwei Disziplinen beherrschen, die sich im selben Kontext befinden.\newline
	Die Ant Ausführungsschritte können im \textit{Groovy}, \textit{Java} oder \textit{Kotlin} Format als \textit{Gradle Tasksk} umgesetzt werden, um die Prozedur ohne Einschränkungen, zusätzlichen Aufwand und Ant Kenntnisse betreiben zu können. 
	
 \subsubsection{Zerlegung der Plugins}
	Dank der Injektion der Moduleigenschaften in Plugins, können die Plugins in das Modulsystem von Java aufgenommen werden und verfügen nun über erweiterte Services, die das Verwalten und Validiert der Code-Bausteine automatisch übernehmen. In der Konsequenz ermöglichen die eingeführten Änderungen den Betrieb der Plugins auf dem Modulpfad, die nun auf alle neuen Features des Modulsystems zugreifen können. Dennoch können Plugins ihre Moduleigenschaften weiter schärfen, um die Idee der Modularisierung weiter zu verfolgen. \newline
	Einer der zentrale Eingenschaften der Module ist ihre Größe, die einen klaren übersichtlichen Aufgabenbereich abdeckt und leicht verstanden sowie ausgetauscht werden kann. Diese Eigenschaft wird nicht von jedem Plugin-Modul umgesetzt, da bestimmte Plugins komplexe Aufgaben lösen und die komplette Verarbeitungskette intern umsetzen. Somit führt die Weiterentwicklung der Plugins zu großen und übersichtlichen Komponenten, die komplexe Aufgaben lösen und die Verarbeitungskette der Teilaufgaben unübersichtlich arrangieren, sodass die Logik nur schwer zu überblickbar ist. Denn, nicht jedes Detail kann sofort wahrgenommen und in der globalen Umsetzung richtig interpretiert werden.\newline
	Um die Verarbeitungsschritte in einem größerem Plugin von einander zu differenzieren, müssen Plugins, die bereits als ein ganzes einzelnes Modul umgesetzt worden sind, in kleinere Aufgabenbereich aufgeteilt und in Moduleinheiten zerlegt werden. Infolgedessen entstehen gekapselte Verarbeitungsschritte die separat verstanden sowie ausgetauscht werden können und bringen damit  \textit{Renew} ein Schritt näher zu einer erstrebenswerte Perspektive der perfekten Umsetzung eines Modularen Systems. \newline
	Die Aufteilung der großen Plugins in kleinere Moduleinheiten, ist eine individuelle und zeitintensive Aufgabe, die ein tiefgründiges und theoretisches Verständnis des Plugins erfordert. Denn, nicht jede mögliche Aufteilung der Code-Blöcke garantiert die Korrektheit der Plugins in ihrer neuen Form. \newline
	In der Konsequenz konnte diese Abschlussarbeit die Aufgabe nicht Umsetzen. Trotzdem bleibt die Aufteilung der Plugins in kleine beherrschbare Module eine grundlegende Herausforderung, die in der Zukunft Thematisiert werden muss. 


 \subsubsection{Grundriss Prototyp}
	Die momentane Umsetzung von \textsc{Renew} basiert auf einem Klassenlader System welches das Entladend der Plugin nicht erlaubt. In der Konsequenz bleiben die Klassen auf dem Klassenpfad, sind immer erreichbar und können nicht aktualisiert werden. Für das geschilderte Problem wurde ein Lösungsansatz \ref{sec:pm} vorgestellt, welcher auf dem Modulsystem von Java aufbaut und eine mögliche Umsetzung für den dynamischen Lademechanismus abbildet. Der vorgestellte Grundriss demonstriert wie die Plugins separat über Modulschichten verteilt und verwaltet werden können.\newline
	Für die Integration des Grundrisses in das Plugin Management, muss der Plugin Manager eine neue Aufgabe übernehmen, nämlich die Aufteilung der Plugins auf die Modulschichten mit den dazugehörigen Drittanbieter Bibliotheken, die Verknüpfung der Modulschichten untereinander und das Laden und Entladen von bestehender oder neu hinzugekommener Plugin Schichten. Des Weiteren müssen für die UI optionale Plugins mit dem \textit{Service Loader} von Java erstellt und verknüpft werden, sodass die UI für sie unbekannte Plugins manipulieren kann. \newline
	Die Aufgabe beschäftigt sich mit der Umsetzung lang gewünschten Verhalten, welches nun mit Java ohne zusätzlichen Drittanbieter Rahmenwerks angegangen werden kann. 

%- Migtation Einleitungssatz 
%- Evaluation des Migrationsablaufes
%	- was wurde dafür getan (modul info)
%	-  nicht alle charactersitica von den good practice müssen umgesetzt werden
%	- wie wurde es getan (automatische expletize unbenannte module ( verweise auf Grundlagen Kapitel))
%	- was für folgen hatte sie (Konfiguration, Transitivität,Kontext, Schichten(Nattürliches ereigniss(hat sich selbst entwicklet)))
%	- Mehrwert  sichtbar ?



% PROJEKTSTRUKTUR 
	% ^-> Anforderungen aus der Modularisierung 
	% -> Probleme die aufgetaucht sind. erwartet, unerwartet, kritik an das Projekt, lob an das Projekt  (pafad umbau lässt)
	% -> Was bringt es auf lange Sicht -> erweiterbarkeit war die anforderung (Mehr module im Plugin) 
	% ^-> Unerwartete mängel wurden behoben ->  stark veraltete und auf zeit unsauberer Projekt aufbau (bilder, resourcen, unterschieldiche Klassen typen und für verschiedenen zweck  im sleben Packet) 
	% ^-> Konvention der modulanamengenbunf, das auf den source aufbau hinweist 
	% -> es Felen konventionen die in der AUssicht näher beschprochen werden 
	% ^-> Konsistenz gegeben, sind die verädnerungen kritisch (Ohne kla defenierte schnissteleln ja (keine schnittstellen verwaltung also ja))?
	% AUFWAND FÜR DIE UMSTRUKTURIERUNG

% MODULARISIERUNG
% -> Modularisierung von  passenden Strukturen sehr einfach aber auch sehr schwer.  Auslesen der zugriffe auf das Modul kahn sehr Müsehlig sein und muss plugin weit getestet und angepasst werden
% -> Die Migration von Modulaen gelingt ohne probleme, jedes MIgrationsszenario kann mit Hilfe der Expliziten automatischen unbenannten und offenen Module abgedeckt werden. Besonders positiv fiel das automaotsiche modul auf, dass  für den Klassenpfad und für den Modulpfad zugägnlich ist und Bausteine einer Bibliothke, schritt für schritt modularisieren lässt.  Modularisierung nicht nur der Code Base sondern der Arbhängigkeiten in kleien Schritten möglich. 
% -> Die Transitive Konfiguration in einem Modulsystem hat einen erheblichen Postivien einfluss auf die Pluginkopplung( Plugin Schichten (Kontexte/ Abhängigkeiten) werden transitiv wietergereicht ohne Komplikation oder verstündniss oder aurbeitsaufwand für aufgliegende module )
% -> Was kan der Prototyp leisten ? wie weit geht die Unterstützung lan  man ihn an weitere Studenten delegieren. tut es was ich versprochen habe 
% -> Konsequenzen für \textsc{Renew} und allgemein für appliaktionen ( was hat \textsc{Renew} erlebt was wird allen zustoßen)
% -> Mehrwert ist da oder nicht ? was kann man mit dem modulsystem von java erreichen
% MODULARISIERUNG \textsc{Mulan} 
% Wleche seite der Modualriseirung hat \textsc{Mulan} gezeigt 
% -> AUFWAND FÜR DSIE MODULARISIERUNG



% GRADLE
% Hat sich das Gradle wärkzueg behauptet ? 
% verstädnlichkeit, 
% code menge, 
% erweiterbarkeit, 
% konfiguration , 
% mehrwert in der nutzung 




% Anforderungsanalyse/Spezifikation
%- Anforderung an Modulariserte Systeme 
%- Charakterisierung (Aufbau Schnittstellen Umfang)
%- Aufwand für Modularisierung
%- Konsequenzen (Zyklen , Splitt Packages ,Alte APIEs)
%- Konsistenz 
%- Mehrwert
%
%- Übergangsphase Aufwand 
%
%- Gradle -> Projektstruktur 
%- Zusätzliche Module Unterstützen 
%- gelöst von der Entwiklungsumgebung 
%- kohärente Arbeitsweise
%- ältere Verfahren 




% Evaluaiere die Anfprderungsanalyse Übergeordnete Kritik 
% Hat sich das Gradle wärkzueg behauptet ? verstädnlichkeit, code menge, erweiterbarkeit, konfiguration , mehrwert in der nutzung 
% Modularisierung konsequenzen für Systeme 
% 

% Was wollte ich erreichen 
% Unterziele 
% Bewertung der Unterziehle 




% Was habe ich erreicht 


