\chapter{Gesamtevaluation}
Dieses Kapitel evaluiert die gesetzten Anforderungen aus der Anforderungsanalyse sowie der Anforderungsspezifikation und bewertet die Migration auf das Modulsystem von Java.\bigbreak	

\section{Projektstruktur}
Für den Ersatz der veralteten Projektorganisation des Quellcodes wird die geforderte Projektstruktur in ein Maven Standard Layout überführt, welches den Java Code von den Java Compiler-Compiler Code trennt und die dazugehörigen Ressourcen separat verwaltet. Zusätzlich wurde die interne Struktur der Plugin Pakete, die sich mit anderen Plugins überschneiden aufgelöst und umbenannt, um den Java Anforderung des Modulpfades zu entsprechen. Darüber hinaus wurde ein Modulname eingeführt, der nach der Java Konvention mit den Organisations- oder Applikationsdomäne beginnt und mit den Feature Namen endet. Der neue Modulname fasst den Quellcode eines Moduls zusammen und ermöglicht das Erstellen zusätzlicher Module innerhalb eines Plugins, die ein gemeinsames Ziel verfolgen. Des Weiteren spiegelt der Modulname die interne Paketstruktur wider und gestaltet die Codebasis leserlich und verständlich, da die Entwickler sofort ablesen können, aus welchen Modulen die Klassen stammen und für welchen Zweck diese entwickelt worden sind.\newline
Der Aufwand für die Umstrukturierung war wie erwartet groß, denn die Modernisierung der internen Struktur eines Elements aus einem gekoppelten Verband diverse Folgen für die Zugriffe auf dessen Ressourcen und Funktionalität mit sich bringt. Demnach müssen alle Zugriffe auf das Plugin angepasst, die \textit{import} Angaben Plugin-Weit überarbeitet und die existierende Meta-Information angeglichen werden. In Folge dessen wurden Änderungen nötig, die Plugin-Übergreifend aufgelöst werden müssen und über den Rahmen des Plugins hinausgehen. Dies führt zu Unsicherheit, da Änderungen in mehre als hundert Klassen entstehen und die Konsistenz der kompletten Applikation in Frage stellt. \newline
Im Endeffekt ist die Umsetzung einer neuen Projektstruktur in einer ausgereiften Applikation eine wichtige und verantwortungsvolle Aufgabe, die  Nachhaltigkeit und Beständigkeit mit sich bringt.\bigbreak

\section{Migration}
Während der Modularisierung des ersten Prototyps, der die kontinuierliche Migration abdeckt, wurde der gemischte Betrieb von modularisiertem \textsc{Renew} Code mit dem Altsystem betrachtet. Dementsprechend sollte die Migration nicht nur Module bilden und das Ergebnis begutachten, sondern auch die fortlaufende Integrität mit dem Altsystem inspizieren.\newline
Die Migration verfolgte den \textit{Chicken little} Ansatz und nutzte die von Java zur Verfügung gestellten Kommunikationsbrücke, die den Klassenpfad mit dem Modulpfad verbindet. Somit entstand kein zusätzlicher Aufwand für die manuelle Erstellung und die nachfolgende Qualitätskontrolle eines unentbehrlichen Elements. Da die Kommunikationsbrücke das Herzstück einer \textit{Chicken little} Migration umsetzt, ist die benannte Kommunikationsbrücke ein begehrenswertes und willkommenes Ausstattungsmerkmal des Modulsystems von Java, die einen großen Teil des Migrationsszenarios übernimmt. Dementsprechend musste im Laufe der Migration nur auf die Adaption an die neue Umgebung geachtet werden, da die Kontextübergreifende Kommunikation sowie dessen Integrität bereits von Java zur Verfügung gestellt worden ist. \newline
Obwohl Java die Migration mit Migrationskonzepten unterstützt, entscheidet sie nicht in welchen Ablauf der Code Modularisiert werden soll. Daher wurden im Grundkapitel Konzepte vorgestellt, die nach der Größe einer Applikation Modularisierungsszenarien empfehlen. Für die \textsc{Renew} Modularisierung wurde das \textit{bottom up} Verfahren ausgewählt, da dieses als das präferierte Verfahren für gekoppelte Bibliotheksstrukturen gilt und sich gut auf das Plugin Konzept übertragen lässt. Das Verfahren modularisiert und integriert den Code, von den simplen bis zu den komplizierten Plugins, in das bestehende System und gliedert zusätzlich die Drittanbieter Bibliotheken als automatische Module ein.\bigbreak

\section{Modularisierung}
Auch wenn die bereits eingerichtete Projektstruktur und der Umsetzungsplan einen großen Teil der Modularisierung ausmachen, mussten die Plugins mit einer Schnittellenbeschreibung in Form einer \textit{module-info.java} ausgestattet werden, um als ein explizites Modul gelten zu dürfen. Das Anreichern der ersten Plugins mit einer Modulbeschreibung geschieht mühelos, da die Konfigurationsdatei eine schlichte Schnittstellenbeschreibung besitzt, die nur das nötigste anfordert und nur wenig anbietet. Jedoch mussten diese während der gesamten Migration durchgehend nachgepflegt werden, da für jedes nachträglichen Plugin, Pakete in bereits modularisierten Plugins geöffnet werden mussten. Somit entstand ein fortlaufender Arbeitsaufwand beim Überarbeiten von bereits deklarierten Schnittstellen in den benötigten Plugins.\newline
Ebenso wichtig ist die Adaption der Plugin Ressourcen, die von dem Modulsystem von Java gekapselt und für die Nutzung explizit in der \textit{module-info.java} geöffnet werden müssen. Diese Mechanik weist einen unerwarteten Effekt auf die Plugins auf, die aufeinander aufbauen, ähnliche Paketnamen für die Ressourcengliederung belegen und diese global wiederverwenden.\newline
Die Umsetzung des modularen Prototyps reorganisiert die Ressourcen und verlegt sie in das \textit{META-INF} Verzeichnis, welches keinen ausführbaren Code enthalten kann und in jedem Plugin existierend darf, ohne die eindeutig Paketeigenschaft zu verletzen. Somit ist es eine gute Wahl, um einen global einheitlichen Aufbau zu folgen. Die Umsetzung für die gestellte Anforderung benötigte mittleren Aufwand, da jedes Plugin eine eigene Vorgehensweise für das Laden der Ressourcen implementiert und mit direkten \textit{String} Konstellationen oder durch die Zusammensetzung der \textit{Path} Objekten arbeitet. \newline
Nichtsdestotrotz erwies sich die Durchführung als Vorbildhaft, denn die Abarbeitung der gesetzten Ziele und der entsprechenden Ausführungsschritte ergaben einen makellosen Weg vom bestehenden Altsystem auf das modernen Modulsystem von Java.\bigbreak

Als Folge der Modularisierung der \textsc{Renew} Plugins inklusive der entsprechen Abhängigkeiten entsteht eine Applikation mit einem globalen übersichtlichen Abhängigkeitsgraphen, der die Evaluation der gesamten Konstruktion ermöglicht. Die Betrachtung ergab eine große Anzahl an transitiven Abhängigkeiten, die mithilfe des \textit{transitiv} Schlüssel innerhalb der \textit{module-info.java} auf eine reduzierte Form des Abhängigkeitsgraphen runter gebrochen werden konnte und ergab somit eine alternative Sicht auf die Plugin Konstellation. Der neue Abhängigkeitsgraph illustriert eine natürliche Schichtenbildung von Plugins, die sich aus grundlegend bis zu erweiterten Fähigkeiten zusammensetzen. Darüber hinaus impliziert die transitive Deklaration der Abhängigkeiten ihre Delegation an Module, die dieses nutzen möchten. In der Konsequenz kann der gesamte Kontext eines Plugins auf Plugins, die dieses erweitern, weitergereicht werden. \newline
Angewandt an die \textsc{Renew} Applikation, ist die transitive Deklaration der Modulabhängigkeiten eine großartige Ergänzung der Plugin Architektur, denn ab diesen Zeitpunkt wird der Kontext der zu erweiternden Plugins an den aufbauenden Plugin unaufgefordert weitergereicht, ohne dass die aufbauenden Plugins sich um die globale Struktur und Abhängigkeitsverwaltung kümmern müssen. Dazu gehören die Plugin Grundlagen, Drittanbieter Bibliotheken sowie die entsprechende Versionierung.\bigbreak

Die \textit{module-info.java} erwirkt weitere Vorteile, die das Verwalten der Plugin Module erleichtern. Dazu zählten native Java API's und Services, die die Administration der angebotenen Schnittstellen, die auslese der Angeforderten Module, die Feststellung des Modultyps, den Aufenthaltsort des Moduls sowie seinen Einstiegspunkt  führen. In der Konsequenz bietet die \textit{module-info.java} eine Alternativen Informationsträger für den größten Teil der \textit{plugin.cfg} Inhalts. Dies entspricht den gesetzten Erwartungen des modularen Forschungsaspekts im \textsc{Renew} Kontext und eröffnet neue Umsetzungsmöglichkeiten des Plugin Managements.\newline
Um den Austausch der \textit{plugin.cfg} durchführen zu können, muss der \textsc{Renew} Plugin Manager modernisiert und auf die neue Konfigurationsdatei angepasst werden. Dementsprechend ist das Auslesen der benötigten Information und die neue Implementation sowie Interpretation der Plugin Organisation ein zentrales Thema für die Übergang auf die native Java Konfigurationsdatei. Darüber hinaus ist das Konzept der Modulschichten eine anknüpfende Technik, die der Plugin Manager in der Zukunft in betreuen muss, um die Plugins sowie benötigten Drittanbieter-Bibliotheken auf die Schichten der Abhängigkeitskette sachgemäß zu instanziieren.\newline
Obwohl die \textit{plugin.cfg} abgelöst werden kann, bleibt der Plugin Manager das Herzstück von \textsc{Renew} und bedarf einen erheblichen Umstellungsaufwand für den Umstieg auf die neu eingeführten Java Features.\bigbreak

\section{Modulschichten}
Die neue eingeführten Modulschichten bauen auf dem Modulkonzept auf und adressieren gezielt die Administration der Java Codebasis während der Laufzeit. Dafür wurden drei wichtige Verwaltungsobjekte eingeführt, nämlich der \textit{Modul-Sucher}, die \textit{Konfiguration} und die \textit{Modulschicht} selbst, die den Zustand der Applikation überwacht, validiert, und manipuliert. Dementsprechend ist zu jedem Zeitpunkt bekannt welche Module während des Betriebs involviert sind, ob das ergänzende Modul die Konsistenz der Applikation beeinträchtigt und kann zusätzlich die Beziehungen zwischen den Modulen nach Belieben abwandeln. In dem Kapitel \ref{sec:pm} wurden bereits die Vorzüge der Modulschicht diskutiert und auf die Plugin Architektur abgebildet, jedoch sind beim Erarbeiten des Grundrisses unerwartetes Verhalten festgestellt worden.\newline
Die Modulschicht soll für die Applikation eine Modulabhängigkeitsgraphen erstellen, der für die Ausführung nur notwendige Module enthält und nicht benötigte Module außen vorgelassen. Dieses Verhalten wird von dem Modulsystem nur zum Teil verfolgt, denn die automatischen Module tragen in sich keine Modulbeschriftungen und werden aus diesem Grund von der Java Plattform an alle Module in der entsprechenden Schicht gekoppelt. Somit ist jedes Modul in einer Schicht mit jedem automatischen Modul verbunden, auch wenn diese miteinander nicht interagieren. Daraus folgt ein unnötiges Laden aller automatischen Module aus der gegebenen Ordnerstruktur und macht das Verwalten von nicht modularisierten Drittanbieter Bibliotheken aus einer zentralen Stelle problematisch. Da \textsc{Renew} alle Drittanbieter Bibliotheken aus einem Verzeichnis steuert, muss für die saubere Schichtenbildung jedes Plugin mit den genutzten Drittanbieter Bibliothek separat organisiert werden.\newline
Ein weiteres unvorhergesehenes Problem entsteht durch die elastische Delegation der Klassen- und Modulsuche, die auf mehrerer Modulschichten verteilt werden kann und trotzdem die Konsistenz der Applikation garantiert.
Durch die variable Anzahl an Modulschichten, können parallel gleichnamige Bibliotheken betrieben werden, ohne die Konsistenz der Applikation in Frage zu stellen. Zum Beispiel durch den Aufbau einer zusätzlichen Schicht, die auf Schichten mit gleichnamigen oder ähnlichen Bibliotheken aufsetzt. Jedoch ist die Konsistenz nicht in allen Fällen der genannten Struktur gegeben. \newline
Die Existenz eines Moduls in mehreren Schichten auf den man aufbaut erzeugt keine Probleme, da die Schicht fix und nicht verendest werden kann und die Suche nach den Modulen in einer strikten Ordnung durchgeführt wird. Dennoch können Module ihre Funktionalität transitiv an die darüberliegenden Module und Schichten anknüpfen und somit eine Inkonsistenz erzeugen. Denn, die Suche kann nun nicht entscheiden welches für das Modul zur Verfügung gestellten Implementation ausgewählt werden soll. \newline
Dennoch ist die Umsetzung des Grundriss-Prototypen vielversprechend und kann das lang gewünschte dynamische Laden und Entladen der Module realisieren. \bigbreak

\section{Konstruktionsumgebung}
Gradle ist ein Code Verwaltungswerkzeug, welches sich auf flexible Konfiguration spezialisiert und im Gegenteil zu Maven die vorgesetzte Struktur flexibel anpassen lässt. Die Flexibilität ist ein Schlüsselkriterium für das Plugin Verband von \textsc{Renew}, da die Plugins in ihrer Auswahl der Technologie, Konfiguration und Aufbereitung der Funktionalität nicht eingeschränkt werden dürfen. Somit sollte jedes Plugin ein gängiges Rahmenwerk für die Verarbeitung enthalten, welches an die Bedürfnisse jedes einzelnen Plugins erweitert und angepasst werden kann. Zuvor hat Ant die benötigte Flexibilität geboten, wurde jedoch mit der Zeit groß, komplex und unübersichtlich. Aus den genannten Gründen wurde Ant ersetzt, und durch das Gradle Werkzeug ausgetauscht.\newline
Der Umstieg von Ant auf Gradle erforderte einen respektablen Aufwand, da man weitgreifende Ant Fachkenntnisse benötigt und von der dürftigen Ant Konvention wenig Unterstützung bekommt. Darüber hinaus muss das Gradle Fachwissen vorhanden sein oder erarbeite werden, um den Übergang einleiten zu können. Somit muss eine Disziplin, nämlich das Bauen einer Applikation, doppelt angeeignet werden und kann folglich nicht jeden Mitarbeiter oder Studenten für die Umsetzung überzeugen. Nichtsdestotrotz ist der Vorteil einer Migrantin auf Gradle enorm und bringt auf lange Sicht ein einfaches-, sauberes-, wartbares- und langlebiges Ergebnis. \bigbreak

Durch die Einführung von Gradle, hat sich der integrierte Lebenszyklus sofort bemerkbar gemacht und lies ein globales Gerüst für das Erstellen aller Plugins an Ort und Stelle anfertigen. Dazu zählt das Abbilden der Projektstruktur, das Konfigurieren der fundamentalen Ausführungsschritte wie \textit{compileJava} und \textit{Jar}. Darüber hinaus konnten \textsc{Renew} bezogenen Ausführungsschritte an Ort und Stelle integriert und auf alle Plugins übertragen werden. Somit konnten Plugins die bereitgestellte Umgebung weiter verfeinern sowie erweitern mit individuell  relevanten Aufgaben. Der genannte Aufbau hat einen positiven Einfluss auf die Lesbarkeit und den Aufwand für das Nachvollziehen und Konfigurieren der Plugins, sodass neu eingeführten Plugins keine oder nur durch notwendige Ausführungssehritte erweitern müssen, ohne die komplette Umgehung in Betracht zu ziehen. Des Weiteren kann die erstellte Umgebung auf \textit{Mulan} übertragen werden und integriert sich gut in die Entwicklungsumgebung des TGI Forschungsbereichs.\newline
Bei der Umsetzung sind, nichtsdestotrotz unerwartete Ereignisse eingetroffen. Zum Beispiel die Nutzung von \textit{JavaCC}, die das Einbinden eines Gradle-Plugins benötigt und in den Lebenszyklus an der passenden Stelle eingebettet werden mussten, um Java Code vor dem Kompilieren zu generieren. Darüber hinaus benutzt eine große Plugin Anzahl von \textsc{Renew} selbst erstellten Ant Ausführungsschritte, die verbindlich durchgeführt werden müssen, um alle notwendigen Java Klassen sowie Ressourcen, die während der Laufzeit benötigt werden, zu erstellen. Dazu zählt der \textit{CreateShadownets} sowie der \textit{GenerateFSOntology} Ausführungsschritt, der vor dem Kompilieren des entsprechenden Plugins durchgeführt werden müssen. Die Gradle Umgebung integriert in sich eine Ant Instanz und lies die beiden Ant-Tasks aus Gradle ausführen und in den Lebenszyklus integrieren. Somit war die unterstützt von Gradle beim Überführen der Build-Umgebung ein gut durchdachtes und willkommenes Leistungsmerkmal.

\subsection{Zielsetzung}
% was habe  ich getan für das erreich meines ziels und ist es mir gelungen ?

\chapter{Schluss}


\section{Zusammenfassung}

Das Grundlagenkapitel behandelt das Arbeiten mit dem Klassenpfad auf der virtuellen Maschine von Java. Dazu gehören Konzepte wie der \textit{ClassPath} und der \textit{Klassenlader} sowie \textit{Reflektion} und die \textit{Interfaces}, die in der Umsetzung von \textsc{Renew} eine wichtige Rolle spielen. Dementsprechend werden Mechanismen vorgestellten, wie das Auffinden der Klassenaufenthaltsorte, das sichere Laden in die Virtuelle Maschine und das Arbeiten mit unbekannten Klassentypen.\bigbreak

In dem Kapitel der Modularisierung wurden wichtige Konzepte und Eigenschaften der Modularisierung erarbeitet, die in der Zukunft helfen sollen, Module sauber zu entwerfen, zu erstellen oder zu bewerten. Dazu gehören kritische Modul Charakteristika, wie Modulkopplung, Modulbindung, Seiteneffektfreiheit, Modulgröße und Namensräume. \bigbreak

Mithilfe des Migrationskapitels werden zwei wesentliche Vorgehensweisen dargestellt, mit den eine Migration durchgeführt werden kann. Zusätzlich wird auf das Modulsystem von Java eingegangen, das eine bestimmte Vorstellung von einer Kontinuierlichen Migration auf das Modulsystem besitzt. \newline
Die Migration des \textsc{Renew} Prototypen bediene sich dieser Idee und modularisiert die Plugins entsprechend dem \textit{bottom Up} Ansatzes. Darüber hinaus wurden wesentliche Modulsystem Migrationshürden benannt, welche die essenziellen Probleme zusammenfassen. \bigbreak

Das Kapitel der Analyse und Ausgangssituation vermittelt die Zielsetzung und den Umfang der Abschlussarbeit sowie die nachfolgende Durchführung. Es werden Gründe für eine Migration auf das Modulsystem von Java zusammengetragen, die daraus resultierenden Konsequenzen analysiert und anschließend die Anforderung an die bevorstehenden Prototypen behandelt. Zum Schluss wird ein aktueller Zustand der \textsc{Renew} sowie \textsc{Mulan} Software konstruiert, die im Nachfolgenden mit einem Umsetzungsplan die gesetzte Spezifikation erreichen sollen.\bigbreak

In dem Kapitel des modularen \textsc{Renew} Prototypen geht es um die Migration von \textsc{Renew} auf das Modulsystem von Java, die eine kontinuierliche und beispielhafte Migration demonstriert. Diese beinhaltet einen Umsetzungsplan, der die Projektstruktur reorganisiert, das Gradle Werkzeug für die Organisation des Projekts einführt und anschließend das Modulsystem von Java auf die vorbereitete Code-Basis aufsetzt. Zum Schluss folgt eine Evaluation, die den Prototypen auf das Modulsystem von Java optimal abstimmt und Parallelen mit dem Gradle Werkzeug zieht.\bigbreak

Das Kapitel des \textsc{Mulan} Prototypen demonstriert mögliche Schwierigkeiten und den betreffenden Aufwand, der mit dem Austausch einer grundlegend Basis-Software in einem größeren System auftreten könnte. Da das Rahmenwerk \textsc{Mulan} auf dem \textsc{Renew} Simulator aufsetzt und ohne diesen nicht betriebsfähig ist, ist \textsc{Mulan} komplett an \textsc{Renew} während der Kompilation sowie der Laufzeit angewiesen. Daraus folgen Referenz- und Zugriffsschwierigkeiten, die global behoben werden müssen. Zusätzlich wird mit diesen Prototypen eine Übergangsszenario simuliert, das \textsc{Renew} mit dem Gradle Werkzeug und \textsc{Mulan} mit dem Ant Werkzeug zugleich ein funktionierendes Ergebnis liefern. \bigbreak

Zum Schluss wird das Ergebnis der Abschlussarbeit evaluiert, zusammengefasst und der Ausblick für die mögliche Forschung und Ausbau der Prototypen gegeben. 


\section{Ausblick} 
	Mit dieser Arbeit wurde das Modulsystem von Java in die \textsc{Renew} Applikation integriert, organisiert und erforscht. Die Ergebnisse deuten auf eine Aufwertung der Plugin-Eigenschaften, mühelose Projektverwaltung sowie neue Möglichkeiten für die Umsetzung des Plugin-Managements. Dennoch konnten nicht alle auftretenden Fragen an Ort und Stelle geklärt werden.\bigbreak
	Im Folgenden werden offene Fragestellungen gelistet, die für Konsistenz, Erweiterbarkeit und die Fortentwicklung von \textsc{Renew} relevant sind.  
	
 \subsection*{Migration der Plugins}
	\textsc{Renew} besteht aus einer großen Plugin Anzahl, die zu einem gewissen Grad mit einander verzahnt ist. Das  Zusammenfügen der Plugins geschieht mit verschiedenen Verfahren, zu unterschiedlichen Zeitphasen und an diversen Stellen. Somit ist die Modularisierung und das Erstellen der \textsc{Renew} Plugin-Basis keine triviale Aufgabe und benötigt mehr Zeit als zuerst angenommen. Aus diesem Grund konnten nicht alle \textsc{Renew} Plugins in das Modulsystem überführt werden und müssen in der Zukunft nachgepflegt werden. 

 \subsection*{Mulan Integration}
	Der \textsc{Mulan} Prototyp bestätigt den parallelen Betrieb von modularen sowie nicht modularem Code-Bausteinen. Nichtsdestotrotz muss die Agentenplattform in der Zukunft auf das Modulsystem von Java migriert werden und kann von der \textsc{Renew} Umsetzung profitieren.\newline 
	Die \textsc{Mulan} Agenten Plattform orientiert sich an \textsc{Renew} und baut auf demselben Plugin Konzept auf. Dies ermöglicht den Plugin Manager die \textsc{Renew} sowie die \textsc{Mulan} Plugins zu gleich zu verwalten. Daraus folgt eine strukturelle Ähnlichkeit, die mit dem Modulsystem von Java und Gradle ausgenutzt werden kann, indem dieselbe Projektstruktur aufgesetzt und von Gradle in den \textsc{Renew} Kontext für das Kompilieren mit aufgenommen wird.\newline
	Dafür muss die Projektstruktur der \textsc{Mulan} Plugins an die \textsc{Renew} Umsetzung angeglichen und zusätzlich durch eine \textit{build.gradle} Konfigurationsdatei erweitert werden. Somit kann Gradle die globale Konfiguration an alle \textsc{Mulan} Plugins delegieren und jedes \textsc{Mulan} Plugin durch eine individuelle Konfiguration individuell herrichten. 
		
 \subsection*{Abhängigkeitsmanagement}
	Eine wichtige mitgelieferte Fähigkeit von Gradle, ist die Abhängigkeitsverwaltung, die uns mit der passenden Bibliothek und der passenden Version aus dem Web versorgt. Die Abhängigkeitsverwaltung wurde mit den ersten Prototypen in \textsc{Renew} nur zum Teil integriert, da einige Drittanbieter Bibliotheken speziell an \textsc{Renew} angepasst wurden und nicht mehr aus dem globalen Maven-Repository heruntergeladen werden können. Dementsprechend werden die modifizierten Bibliotheken aus dem lokalen Verzeichnis und alle anderen aus dem Web referenziert.\newline
	Für die saubere Umsetzung der Abhängigkeitsverwaltung, müssen die modifizierten Bibliotheken von dem Arbeitsbereich gehosted werden, um das Bandbreite der Internetverbindung zu entlasten und ein schnelles Auschecken des Projekts zu ermöglichen. 	
	
 \subsection*{Rückwärts Kompatibilität}
	Das Problem der \textit{Split Packages} ist in \textsc{Renew} weit verbreitet. Durch die Reorganisation der gesplitteten Pakete ändert sich der Paketname der Klassen, die an vielen Stellen im Code mit einem direkten Verwies genutzt werden. Obwohl die Klassen Verweise gepflegt wurden, können bereits erstellte oder generierte Ressourcen auf der lokalen Maschine des Nutzers, wie zum Beispiel die \textsc{Renew} Netze Zeichnungen, nicht korrekt angezeigt werden, da diese auf den veralteten voll-qualifizierten Klassennamen referenzieren.\newline
	Für die valide Darstellung der \textit{legacy} Zeichnungen, benötigt \textsc{Renew} eine Transferfunktion, die Ressourcen nach funktionsuntüchtigen Klassen abtastet und diese vor dem Öffnen substituiert.
	
 \subsection*{Migration der Ant Ausführungsschritte}
	Die Umsetzung des BPMN Plugins beinhaltet die Aufnahme der benötigten Ant Ausführungsschritte in die neue Gradle Build-Umgebung, die Klassen und Ressourcen für den Betrieb generieren. Dank der nahtlosen Integration von Ant in Gradle, war es möglich die Ausführungsschritte mit minimalem Aufwand aus Gradle aufzurufen und die Funktionalität nahtlos in die Produktion der Bibliothek einzubinden. Jedoch wird der Aufruf über eine von Gradle zur Verfügung gestellte Ant Instanz durchgeführt, welche die Arbeitsweise von Ant voraussetzt. Somit muss \textit{Renew} Entwickler zwei Disziplinen beherrschen, die sich im selben Kontext befinden.\newline
	Die Ant Ausführungsschritte können im \textit{Groovy}, \textit{Java} oder \textit{Kotlin} Format als \textit{Gradle Tasks} umgesetzt werden, um die Prozedur ohne Einschränkungen, zusätzlichen Aufwand und Ant Kenntnisse betreiben zu können. 
	
 \subsection*{Zerlegung der Plugins}
	Dank der Injektion der Moduleigenschaften in Plugins, können die Plugins in das Modulsystem von Java aufgenommen werden und verfügen nun über erweiterte Services, die das Verwalten und Validieren der Code-Bausteine automatisch übernehmen. In der Konsequenz ermöglichen die eingeführten Änderungen den Betrieb der Plugins auf dem Modulpfad, die nun auf alle neuen Features des Modulsystems zugreifen können. Dennoch können Plugins ihre Moduleigenschaften weiter schärfen, um die Idee der Modularisierung weiter zu verfolgen. \newline
	Einer der zentralen Eigenschaften der Module ist ihre Größe, die einen klaren übersichtlichen Aufgabenbereich abdeckt und leicht verstanden sowie ausgetauscht werden kann. Diese Eigenschaft wird nicht von jedem Plugin-Modul umgesetzt, da bestimmte Plugins komplexe Aufgaben lösen und die komplette Verarbeitungskette intern umsetzen. Somit führt die Weiterentwicklung der Plugins zu großen und übersichtlichen Komponenten, die komplexe Aufgaben lösen und die Verarbeitungskette der Teilaufgaben unübersichtlich arrangieren, sodass die Logik nur schwer zu überblickbar ist. Denn, nicht jedes Detail kann sofort wahrgenommen und in der globalen Umsetzung richtig interpretiert werden.\newline
	Um die Verarbeitungsschritte in einem größeren Plugin voneinander zu differenzieren, müssen Plugins, die bereits als ein ganzes einzelnes Modul umgesetzt worden sind, in kleinere Aufgabenbereiche aufgeteilt und in Moduleinheiten zerlegt werden. Infolgedessen entstehen gekapselte Verarbeitungsschritte die separat verstanden sowie ausgetauscht werden können und bringen damit  \textit{Renew} ein Schritt näher zu einer erstrebenswerten Perspektive der perfekten Umsetzung eines Modularen Systems. \newline
	Die Aufteilung der großen Plugins in kleinere Moduleinheiten, ist eine individuelle und zeitintensive Aufgabe, die ein tiefgründiges und theoretisches Verständnis des Plugins erfordert. Denn, nicht jede mögliche Aufteilung der Code-Blöcke garantiert die Korrektheit der Plugins in ihrer neuen Form. \newline
	In der Konsequenz konnte diese Abschlussarbeit die Aufgabe nicht umsetzen. Trotzdem bleibt die Aufteilung der Plugins in kleine beherrschbare Module eine grundlegende Herausforderung, die in der Zukunft thematisiert werden muss. 

 \subsection*{Fortentwicklung des Plugin Managements}
	Die momentane Umsetzung von \textsc{Renew} basiert auf einem Klassenlader-System, welches das Entladend der Plugin nicht erlaubt. In der Konsequenz bleiben die Klassen auf dem Klassenpfad, sind immer erreichbar und können nicht aktualisiert werden. Für das geschilderte Problem wurde ein Lösungsansatz \ref{sec:pm} vorgestellt, welcher auf dem Modulsystem von Java aufbaut und eine mögliche Umsetzung für den dynamischen Lademechanismus abbildet. Der vorgestellte Grundriss demonstriert wie die Plugins separat über Modulschichten verteilt und verwaltet werden können.\newline
	Für die Integration des Grundrisses in das Plugin Management, muss der Plugin Manager eine neue Aufgabe übernehmen, nämlich die Aufteilung der Plugins auf die Modulschichten mit den dazugehörigen Drittanbieter Bibliotheken, die Verknüpfung der Modulschichten untereinander und das Laden und Entladen von bestehender oder neu hinzugekommener Plugin Schichten. Darüber hinaus müssen für die UI optionale Plugins mit dem \textit{Service Loader} von Java erstellt und verknüpft werden, sodass die UI für sie unbekannte Plugins manipulieren kann. \newline
	Die Aufgabe beschäftigt sich mit der Umsetzung lang gewünschten Verhalten, welches nun mit Java ohne zusätzlichen Drittanbieter Rahmenwerks angegangen werden kann. 


% Was wollte ich erreichen 
% Unterziele 
% Bewertung der Unterziehle 
% Maln Zyclus 
% Was habe ich erreicht 


