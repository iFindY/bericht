\chapter{Gesamt Evaluation}
Dieses Kapitel evaluiert die gesetzten Anforderungen aus der Anforderungsanalyse sowie der Anforderungsspezifikation und bewertet die Migration auf das Modulsystem von Java.\bigbreak	

% übergangn  


Für den Ersatz der veralteten Projektorganisation des Quellcodes wird die geforderte Projektstruktur in ein Maven Standard Layout überführt, welches den Java Code von den Java Compiler-Compiler Code trennt und die dazugehörigen Ressourcen separat verwaltet. Zusätzlich wurden die interne Struktur der Plugin Pakete, die sich mit anderen Plugins überschneiden aufgelöst und umbenannt, um den Java Anforderung des Modulpfades zu entsprechen. Darüber hinaus wurde ein Modulname eingeführt, der nach der Java Konvention mit den Organisations- oder Applikationsdomäne beginnt und mit den Feature Namen endet. Der neue Modulname fasst den Quellcode eines Moduls zusammen und ermöglicht das Erstellen zusätzlicher Module innerhalb eines Plugins, die ein gemeinsames Ziel verfolgen. Des Weiteren spiegelt der Modulname die interne Paketstruktur wieder und gestaltet die Codebasis Leserlich und Verständlich, da die Entwickler sofort ablesen können, aus welchen Modulen die Klassen stammen und für welchen Zweck diese entwickelt worden sind.\newline
Der Aufwand für die Umstrukturierung war wie erwartet groß, denn die Modernisierung der internen Struktur eines Elements aus einem gekoppelten Verband diverse Folgen für die Zugriffe auf dessen Ressourcen und Funktionalität mit sich bringt. Demnach müssen alle Zugriffe auf das Plugin angepasst, die \textit{import} Angaben Plugin-Weit überarbeitet und die existierende Meta-Information angeglichen werden. In Folge dessen wurden Änderungen nötig, die Plugin-Übergreifend aufgelöst werden müssen und über den Rahmen des Plugins hinausgehen. Dies führt zu Unsicherheit, da Änderungen in mehre als hundert Klassen entstehen und die Konsistenz der kompletten Applikation in Frage stellt. \newline
Im Endeffekt, ist die Umsetzung einer neuen Projektstruktur in einer ausgereiften Applikation eine wichtige und verantwortungsvolle Aufgabe, die  Nachhaltigkeit und Beständigkeit mit sich bringt.\bigbreak    

Während der Modularisierung des ersten Prototypen, der die kontinuierliche Migration abdeckt, wurde der gemischte Betrieb von modularisiertem \textsc{Renew} Code mit dem alt System betrachtet. Dementsprechend sollte die Migration nicht nur Module bilden und das Ergebnis begutachten, sondern auch die fortlaufende Integrität mit dem Altsystem inspizieren.\newline
Die Migration verfolgte den \textit{Chicken little} Ansatz und nutzte die von Java zur Verfügung gestellten Kommunikationsbrücke, die den Klassenpfad mit dem Modulpfad verbindet. Somit entstand kein zusätzlicher Aufwand für die manuelle Erstellung und die nachfolgende Qualitätskontrolle eines unentbehrlichen Elements. Da die Kommunikationsbrücke das Herzstück einer \textit{Chicken littel} Migration umsetzt, ist die benannte Kommunikationsbrücke ein begehrenswertes und willkommenes Ausstattungsmerkmal des Modulsystems von Java, die einen großen Teil des Migrationsszenarios übernimmt. Dementsprechend musste im Laufe der Migration nur auf die Adaption an die neue Umgebung geachtet werden, da die Kontext übergreifende Kommunikation sowie dessen Integrität bereits von Java zur Verfügung gestellt worden ist. \newline
Obwohl Java die Migration mit Migrationskonzepten unterstützt, entscheidet sie nicht in welchen Ablauf der Code Modularisiert werden soll. Daher wurden im Grundkapitel Konzepte vorgestellt, die nach der Größe einer Applikation Modularisierungsszenarien empfehlen. Für die \textsc{Renew} Modularisierung wurde das \textit{bottom up} Verfahren ausgewählt, da dieses als das präferierte Verfahren für gekoppelte Bibliotheksstrukturen gilt und sich gut auf das Plugin Konzept übertragen lässt. Das Verfahren modularisiert und integriert den Code, von den simplen bis zu den komplizierten Plugins, in das bestehende System und gliedert zusätzlich die Drittanbieter Bibliotheken als automatische Module ein.\newline 
Obwohl die bereits eingerichtete Projektstruktur und der Umsetzungsplan einen großen Teil der Modularisierung ausmachen, mussten die Plugins mit einer Schnittellenbeschreibung in Form einer \textit{module-info.java} ausgestattet werden, um als ein explizites Module gelten zu dürfen. Das Anreichern der ersten Plugins mit einer Modulbeschreibung geschieht mühelos, da die Konfigurationsdatei eine schlichte Schnittstellenbeschreibung besitzt, die nur das nötigste anfordert und nur wenig anbietet. Jedoch mussten diese während der gesamten Migration durchgehend nach gepflegt werden, da für jedes nachträglichen Plugin, Pakete in bereits modularisierten Plugin geöffnet werden mussten. Somit entstand ein fortlaufender Arbeitsaufwand beim Überarbeiten von bereits deklarierten Schnittstellen in den benötigten Plugins.\newline
Nichtsdestotrotz erwies sich die Durchführung als Vorbildhaft, denn die Abarbeitung der gesetzten Ziele und der entsprechenden Ausführungsschritte ergaben einen makellosen Weg vom bestehenden Altsystem auf das modernen Modulsystem von Java.\bigbreak

Als Konsequenz der Modularisierung von \textsc{Renew} samt der entsprechen Abhängigkeiten entsteht eine Applikation mit einem globalen übersichtlichen Abhängigkeitsgraphen, der die Evaluation der gesamten Konstruktion ermöglicht. Die Betrachtung ergab eine große Anzahl an transitiven Abhängigkeiten, die mithilfe des \textit{trantiv} Schlüssel auf eine reduziert Form des Abhängigkeitsgraphen runter gebrochen werden konnten und ergaben somit eine alternative Sicht auf die Plugin Konstellation. Der neue Abhängigkeitsgraph illustrierte eine natürliche Schichtenbildung von Plugins, die sich aus grundlegend bis zu erweiterten Fähigkeiten zusammensetzen. Des Weiteren impliziert die transitive Deklaration der Abhängigkeiten ihre Delegation an Module die dieses Nutzen möchten. In der Konsequenz kann der gesamte Kontext eines Plugins auf Plugins, die dieses erweitern, weitergereicht werden. \newline
Angelwand an die \textsc{Renew} Applikation, ist die transitive Deklaration der Modulabhängigkeiten eine großartige Erweiterung der Plugin Architektur, denn ab diesen Zeitpunkt wird der Kontext der zu erweiternden Plugins an den aufbauenden Plugin \textit{automatisch} weitergereicht, ohne dass die aufbauenden Plugins sich um die globale Struktur und Abhängigkeitsverwaltung kümmern müssen. Dazu gehören die Plugin Grundlagen, Drittanbieter Bibliotheken sowie die entsprechende Versionierung. \newline



\chapter{Schluss}


\section{Zusammenfassung}

Das Grundlagenkapitel behandelt das Arbeiten mit dem Klassenpfad auf der virtuellen Maschine von Java. Dazu gehören Konzepte wie der \textit{Classpath} und der \textit{Classloader} sowie \textit{Reflection} und die \textit{Interfaces}, die in der Umsetzung von \textsc{Renew} eine wichtige Rolle spielen. Dementsprechend werden Mechanismen vorgestellten, wie das Auffinden der Klassenaufenthaltsorte, das sichere Laden in die Virtuelle Maschine und das Arbeiten mit unbekannten Klassentypen.\bigbreak

In dem Kapitel der Modularisierung wurden wichtige Konzepte und Eigenschaften der Modularisierung erarbeitet, die in der Zukunft helfen sollen, Module sauber zu entwerfen, zu erstellen oder zu bewerten. Dazu gehören kritische Modul Charakteristika, wie Modulkopplung, Modulbindung, Seiteneﬀektfreiheit, Modulgröße und Namensräume. \bigbreak

Mithilfe des Migrationskapitels werden zwei wesentliche Vorgehensweisen dargestellt, mit den eine Migration durchgeführt werden kann. Zusätzlich wird auf das Modulsystem von Java eingegangen, das eine bestimmte Vorstellung von einer Kontinuierlichen Migration auf das Modulsystem besitzt. \newline
Die Migration des \textsc{Renew} Prototypen bediene sich dieser Idee und modularisiert die Plugins entsprechend dem \textit{bottom Up} Ansatzes. Darüber hinaus wurden wesentliche Modulsystem Migrationshürden benannt, welche die essenziellen Probleme zusammenfassen. \bigbreak

Das Kapitel der Analyse und Ausgangssituation vermittelt die Zielsetzung und den Umfang der Abschlussarbeit sowie die nachfolgende Durchführung. Es werden Gründe für eine Migration auf das Modulsystem von Java zusammengetragen, die daraus resultierenden Konsequenzen analysiert und anschließend die Anforderung an die bevorstehenden Prototypen behandelt. Zum Schluss wird ein aktueller Zustand der \textsc{Renew} sowie \textsc{Mulan} Software konstruiert, die im Nachfolgenden mit einem Umsetzungsplan die gesetzte Spezifikation erreichen sollen.\bigbreak

In dem Kapitel des modularen \textsdc{Renew} Prototypen geht es um die Migration von \textsc{Renew} auf das Modulsystem von Java, die eine kontinuierliche und beispielhafte Migration demonstriert. Diese beinhaltet einen Umsetzungsplan, der die Projektstruktur reorganisiert, das Gradle Werkzeug für die Organisation des Projekts einführt und anschließend das Modulsystem von Java auf die vorbereitete Code-Basis aufsetzt. Zum Schluss folgt eine Evaluation, die den Prototypen auf das Modulsystem von Java optimal abstimmt und Parallelen mit dem Gradle Werkzeug zieht.\bigbreak
% proptotypen kapitel 

 Das Kapitel des \textsc{Mulan} Prototypen demonstriert mögliche Schwierigkeiten und den betreffenden Aufwand, der mit dem Austausch einer grundlegend Basis-Software in einem größeren System auftreten könnte. Da das Rahmenwerk \textsc{Mulan} auf dem \textsc{Renew} Simulator aufsetzt und ohne diesen nicht betriebsfähig ist, ist \textisc{Mulan} komplett an \textsc{Renew} während der Kompilation sowie der Laufzeit angewiesen. Daraus folgen Referenz- und Zugriffsschwierigkeiten, die global behoben werden müssen. Zusätzlich wird mit diesen Prototypen eine Übergangsszenario simuliert, das \textsc{Renew} mit dem Gradle Werkzeug und \textsc{Mulan} mit dem Ant Werkzeug zugleich ein funktionierendes Ergebnis liefern. \bigbreak

 Zum Schluss wird das Ergebnis der Abschlussarbeit evaluiert, zusammengefasst und der Ausblick für die mögliche Forschung und Ausbau der Prototypen gegeben. 


\section{Ausblick} 



\newpage

- Migtation Einleitungssatz 
- Evaluation des Migrationsablaufes
	- was wurde dafür getan (modul info)
	-  nicht alle charactersitica von den good practice müssen umgesetzt werden
	- wie wurde es getan (automatische expletize unbenannte module ( verweise auf Grundlagen Kapitel))
	- was für folgen hatte sie (Konfiguration, Transitivität,Kontext, Schichten(Nattürliches ereigniss(hat sich selbst entwicklet)))
	- Mehrwert  sichtbar ?



% PROJEKTSTRUKTUR 
	% ^-> Anforderungen aus der Modularisierung 
	% -> Probleme die aufgetaucht sind. erwartet, unerwartet, kritik an das Projekt, lob an das Projekt  (pafad umbau lässt)
	% -> Was bringt es auf lange Sicht -> erweiterbarkeit war die anforderung (Mehr module im Plugin) 
	% ^-> Unerwartete mängel wurden behoben ->  stark veraltete und auf zeit unsauberer Projekt aufbau (bilder, resourcen, unterschieldiche Klassen typen und für verschiedenen zweck  im sleben Packet) 
	% ^-> Konvention der modulanamengenbunf, das auf den source aufbau hinweist 
	% -> es Felen konventionen die in der AUssicht näher beschprochen werden 
	% ^-> Konsistenz gegeben, sind die verädnerungen kritisch (Ohne kla defenierte schnissteleln ja (keine schnittstellen verwaltung also ja))?
	% AUFWAND FÜR DIE UMSTRUKTURIERUNG

% MODULARISIERUNG
% -> Modularisierung von  passenden Strukturen sehr einfach aber auch sehr schwer.  Auslesen der zugriffe auf das Modul kahn sehr Müsehlig sein und muss plugin weit getestet und angepasst werden
% -> Die Migration von Modulaen gelingt ohne probleme, jedes MIgrationsszenario kann mit Hilfe der Expliziten automatischen unbenannten und offenen Module abgedeckt werden. Besonders positiv fiel das automaotsiche modul auf, dass  für den Klassenpfad und für den Modulpfad zugägnlich ist und Bausteine einer Bibliothke, schritt für schritt modularisieren lässt.  Modularisierung nicht nur der Code Base sondern der Arbhängigkeiten in kleien Schritten möglich. 
% -> Die Transitive Konfiguration in einem Modulsystem hat einen erheblichen Postivien einfluss auf die Pluginkopplung( Plugin Schichten (Kontexte/ Abhängigkeiten) werden transitiv wietergereicht ohne Komplikation oder verstündniss oder aurbeitsaufwand für aufgliegende module )
% -> Was kan der Prototyp leisten ? wie weit geht die Unterstützung lan  man ihn an weitere Studenten delegieren. tut es was ich versprochen habe 
% -> Konsequenzen für \textsc{Renew} und allgemein für appliaktionen ( was hat \textsc{Renew} erlebt was wird allen zustoßen)
% -> Mehrwert ist da oder nicht ? was kann man mit dem modulsystem von java erreichen
% MODULARISIERUNG \textsc{Mulan} 
% Wleche seite der Modualriseirung hat \textsc{Mulan} gezeigt 
% -> AUFWAND FÜR DSIE MODULARISIERUNG



% GRADLE
% Hat sich das Gradle wärkzueg behauptet ? 
% verstädnlichkeit, 
% code menge, 
% erweiterbarkeit, 
% konfiguration , 
% mehrwert in der nutzung 




% Anforderungsanalyse/Spezifikation
%- Anforderung an Modulariserte Systeme 
%- Charakterisierung (Aufbau Schnittstellen Umfang)
%- Aufwand für Modularisierung
%- Konsequenzen (Zyklen , Splitt Packages ,Alte APIEs)
%- Konsistenz 
%- Mehrwert
%
%- Übergangsphase Aufwand 
%
%- Gradle -> Projektstruktur 
%- Zusätzliche Module Unterstützen 
%- gelöst von der Entwiklungsumgebung 
%- kohärente Arbeitsweise
%- ältere Verfahren 




% Evaluaiere die Anfprderungsanalyse Übergeordnete Kritik 
% Hat sich das Gradle wärkzueg behauptet ? verstädnlichkeit, code menge, erweiterbarkeit, konfiguration , mehrwert in der nutzung 
% Modularisierung konsequenzen für Systeme 
% 

% Was wollte ich erreichen 
% Unterziele 
% Bewertung der Unterziehle 




% Was habe ich erreicht 


