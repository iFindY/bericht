\chapter{Modularisierung} \label{cha:modularisierung}

% \section{Modularisierung} \label{sec:modularisierung}
  Modularisierungsansätze finden sich so gut wie in jeder Software wieder, da es sich um ein grundlegendes Prinzip für die Beherrschung eines Systems handelt. Gerade in der Java-Welt wird seit jeher das Ideal von lose gekoppelten Systemen verfolgt, denn diese generieren die Struktur in großen Softwareprojekten, indem das Gesamtprodukt in kleine und praktische Bestandteile zerlegt wird. \bigbreak
  
  Die Entwicklung von kleinen Projekten mit einer übersichtlichen Codebasis ist einfach zu überblicken und bedarf keiner strukturellen Unterstützung, um den Entwickler, Architektur und Funktion darzustellen. Dennoch ist die Zukunft eines Projekts nicht immer eindeutig und kann mit der Zeit an Größe und Komplexität gewinnen. Mit der Größe des Projektes, wächst der Geschäftskontext und damit die Zahl der beteiligten Personen. Diese repräsentieren verzwickte Wünsche und Ziele, die an einer Stelle im Projekt nicht sauber umsetzbar sind. Infolge dessen ist die richtige Aufstellung eines Projektes von Grund auf eine zukunftssichere Entscheidung.\bigbreak 

  Ohne die Modularisierung werden Änderungen an großen Projekten mühselig und mit unerwarteten Nebeneffekten umgesetzt. Sowohl das Bauen und Ausrollen des Projekts, als auch der Betrieb der Applikation, ist eine lange und aufwendige Aufgabe, die mit jedem kleinen Fehler die komplett Applikation neustarten lässt oder das Ausrollen unterbricht. Somit können kleine Fehler das ganze Produkt aus dem Gleichgewicht bringen. Aus diesem Grund sollen Module diese Probleme adressieren und die Applikation in autonome, kleine Einheiten aufteilen, die unabhängig voneinander ihre Funktionalität anbieten.

  % Moduleigenschaften 
  \section{Ziele der Modularisierung} \label{sec:ZdM}
    Die Modularisierung beschäftigt sich mit der Aufteilung eines Systems in Module, die Komplexität verringern, indem die einzelnen Module getrennt voneinander betrachtet und verstanden werden. Dies wiederum unterstützt die Wartbarkeit der einzelnen Module. Darüber hinaus vereinfachen die von der Modularität geforderte Schnittstellenspezifizierung die Kommunikation zwischen den Modulen und fördert damit die Erweiterbarkeit des Systems. Da die Module austauschbar sind und unabhängig voneinander betrieben werden können, eröffnen sich neue Möglichkeiten der Softwareentwicklung. Wie zum Beispiel die Erstellung verschiedenen Varianten der Umsetzung, durch die Rekombination existierender Module, ohne die ganze Applikation zu in Betracht zu ziehen.\cite{javaMod9,java9modRevealed,explorJava9}\bigbreak

    Um die Aufgabe der Java Modularisierung zu verstehen, bedarf es einer Aufstellung von Zielen und Qualitäten, denen sich die Modularisierung stellt. Für JPMS sind diese eindeutig in der \textit{JSR 376} \cite{jmsOracle,java9modRevealed} beschrieben und spezifizieren die folgenden Qualitäten:

    \subsubsection{Kapselung}
      Die Kapselung beschreibt ein Kontrollmechanismus, der die interne Struktur eines Moduls verwaltet. Demzufolge hat das Modul die komplette Kontrolle über ihre interne Struktur und kennt die Zugriffsrechte ihrer Bestandsteile, indem das Modul die Zugriffsrechte ihrer inneren Struktur explizit deklariert.

    \subsubsection{Interoperabilität}
      Die Interoperabilität beschreibt die Kommunikationsfähigkeit der Software mit anderen diversen Systemen, unabhängig von ihrer Sprache oder Plattform. Darum bieten Module Schnittstellen an, mit denen sie Dienste anbieten und anfordern können.

    \subsubsection{Zusammensetzbarkeit}
      Aus der Interoperabilität geht die Zusammensetzbarkeit hervor. Diese steht für die Wiederverwendbarkeit der abgeschlossenen Module, die auf bestimmte Art und Weise kombiniert, und für unterschiedliche Zwecke in unterschiedlichen Systemen, eingesetzt werden können.

    \subsubsection{Erweiterbarkeit}
     Die Erweiterbarkeit hilft den modularen und zusammengesetzten Systems ihre Funktionalität zu skalieren, indem die Software durch individuelle Einheiten ergänzt werden kann. 

    \subsubsection{Autonomie}
      Mit der Autonomie werden unnötige Abhängigkeiten aufgelöst und nur die nötige Funktionalität für die entsprechende Aufgabe in einem Modul abgelegt. Somit können einzelne Module im Betrieb auch dann bleiben, wenn Teile des Systems nicht reagieren.

  % Modulaufbau 
  \section{Grobe Modulstruktur}
      Die zuvor aufgeführten Ziele der Modularisierung liefern bereits eine Vorstellung der Modulanforderungen.
        \begin{figure}[h!] 
        \centering
        \includegraphics[width=0.4\textwidth]{material/images/simple-module.pdf}
        \caption{Simple Modulstruktur \cite{modulMitJava9}}
        \label{fig:simple-module}
      \end{figure}
    Primär erfüllt ein Modul einen abgeschlossenen Aufgabenbereich und beinhaltet die dafür nötigen öffentlichen, sowie privaten Operationen und Datenfelder. Die Kommunikation eines Moduls mit anderen Modulen und der Außenwelt, erfolgt über eindeutig spezifizierte Schnittstellen \ref{fig:simple-module}.\newline
    Somit dient das Modul als ein Behälter für Objekte, der aus einem unsichtbaren und einem sichtbaren Bereich besteht(grau und grün in der Abbildung \ref{fig:simple-module}). Der sichtbare Bereich ist die Schnittstelle des Moduls, und ist die Aufzählung derer Objekte, die das Modul nach außen hin zur Verfügung stellt. Der Zugriff auf diese erfolgt über definierte Operationen in der Modulschnittstelle. Der unsichtbare Teil beherbergt die eigentliche Implementierung, also die umgesetzten Operationen und die Daten. Unter diesen Umständen reduziert sich die Komplexität des Moduls von der gesamten Implementation auf die Schnittstellen für den Nutzer. \cite{javaMod9,java9modRevealed,explorJava9,modulMitJav9}

      \begin{figure}[h!]
        \centering
        \includegraphics[width=\textwidth]{material/images/Module-workflow.pdf}
        \caption{Schematischer Aufbau eines Moduls \cite{modulMitJava9}}
        \label{fig:mw}
      \end{figure} 

    In der Abbildung \ref{fig:mw} werden die interne Struktur und die entsprechenden Verbindungen eines Moduls genau betrachtet. Zu sehen sind drei Module, die ihre Dienste mit dem \textit{exports} Schlüssel über die Schnittstellen anbieten und diese bei Bedarf mit anderen Modulen kombinieren können, indem weitere Funktionalitäten durch den \textit{requires} Schlüssel von zusätzlichen Modulen angefordert werden. Die interne Umsetzung der Funktionalität bleibt jedoch verborgen und kann modulübergreifend nicht nachverfolgt werden. 

  % Moduldefenition schlussatz als zusammenfassung 
  \section{Moduleigenschaften} \label{sec:ME}

    \textbf{Modul Definition: } \textit {Ein Modul ist eine Sammlung von Algorithmen und Daten bzw. Datenstrukturen zur Bearbeitung einer in sich abgeschlossenen Aufgabe. Die Verwendung des Moduls (d.h. seine Integration in ein Programm-System) erfordert keine Kenntnis seines inneren Aufbaus und der konkreten Realisierung der gekapselten Algorithmen und Daten(-strukturen). Seine Korrektheit ist ohne Kenntnis seiner Einbettung in ein bestimmtes Programm-System nachprüfbar.} \cite{rechenberg2006informatik}\bigbreak 

    Aus dieser Definition können folgende Eigenschaften abgeleitet werden, die ein Software-Modul beschreiben:

    \begin{itemize}
      \item Zusammenfassung von Operationen und Daten zur Realisierung einer in sich abgeschlossenen Aufgabe 
      \item Kommunikation mit der Außenwelt nur über eine eindeutig spezifizierte Schnittstelle 
      \item Nutzung des Moduls möglich ohne Kenntnis des möglichen Ablaufs 
      \item Die Struktur jedes Moduls sollte genug sein, um vollständig verstanden zu werden
      \item Anpassungen eines Moduls sollte ohne Kenntnis der Implementierung, sowie ohne Einfluss auf das Verhalten anderer Module durchführbar sein
      \item Korrektheit des Moduls durch Tests nachprüfbar, ohne Kenntnis seiner Einbettung
      \item Wiederverwendbarkeit der Funktionalität im anderen Kontext
    \end{itemize}

  % Wie modelliert man Module  
  \section{Modulentwurfskriterien} \label{sec:MEK}
    % Einleitung
    Nachdem die Struktur des Moduls klar bestimmt wurde, muss die Umsetzung einer Applikation mit Modulen auf Qualitätsmerkmale abgeglichen werden. Da die Aufteilung eines Entwurfsproblems in kleinere Teilprobleme nicht selbstverständlich ist, kann diese mit verschieden Techniken und auf diverse Weise umgesetzt werden und bietet daher keine Garantie eines sauberen Entwurfs. Die Möglichkeit Funktionalität in einem einzelnen Modul zu kapseln und diese mit geringer Abhängigkeit vom Restsystem betreiben zu können, kann mithilfe bestimmter Kriterien bewertet und angepasst werden. \cite{softModDes,softMdDes2,modulMitJava9,java9modRevealed,modulProgJava9}\bigbreak
    
    Bei der Modularisierung sind folgende Entwurfskriterien zu berücksichtigen: 
    \begin{itemize}
      \item Modulgeschlossenheit 
      \item Maximale Modulbindung 
      \item Minimale Modulkopplung 
      \item Minimale Schnittstelle 
      \item Modulanzahl 
      \item Modulgröße 
      \item Testbarkeit 
      \item Seiteneffektfreiheit 
      \item Importzahl 
      \item Modulhierarchie 
    \end{itemize}
    Mithilfe der \textit{Modulgeschlossenheit} wird die Abhängigkeit des Moduls von anderen Modulen reduziert und lässt diese separat bearbeiten und austauschen. Somit kapselt ein Modul eine bestimmte Funktionalität, die von Anfang bis zum Ende, intern verarbeitet werden kann. Direkt daraus folgt im besten Fall eine \textit{maximale Bindung}, oder ein starker Zusammenhang innerhalb eines Moduls, indem die internen Komponenten bestens miteinander verzahnt sind und sich gemeinsam mit einer gezielten Aufgabe beschäftigen. In der Konsequenz, entsteht ein eingeschränkter Wartungsraum für Entwickler, die sich mit der entsprechenden Funktion beschäftigen. Um die Bindung der Komponenten innerhalb eines Moduls zu messen, können die Abhängigkeiten in verschieden Kategorien eingeteilt werden: logisch, zeitlich, prozedural, sequentiell, informal und funktional.

    \begin{figure}[h]
      \includegraphics[width=\textwidth]{material/images/kopplung.pdf}
      \caption{Modulbindung und Modulkopplung \cite{modulMitJava9}}
      \label{fig:kopplung}
    \end{figure}

    Komplementär zu der \textit{maximalen Bindung} beschreibt die \textit{minimale Kopplung} die Anzahl der Verbindung zwischen den Modulen. Diese sollte natürlich klein gehalten werden, um die Abhängigkeit zu reduzieren. Die \textit{minimale Kopplung} hat somit einen direkten und positiven Einfluss auf die Anzahl der Schnittstellen, indem diese übersichtlich und eindeutig die Funktion des Moduls beschreiben. Andernfalls, kann eine starke Kopplung die Komplexität heben und Fehler begünstigen, indem der Umfang an Daten, die zwischen den Modulen ausgetauscht werden, erhöht wird. Eine \textit{minimale Kopplung} ist ein guter Ansatz den unnötigen Datentransfer zu reduzieren, garantiert aber keine lose Kopplung von den umgebenen Modulen. Daher sollte der Begriff \textit{Seiteneffektfrei} eingeführt werden. Dieser beschreibt den Einfluss eines Moduls auf seine Umgebung, indem das Modul unverzichtbar für die Gesamtfunktionalität wird und sein Austausch die Anpassung verknüpfter Module nach sich zieht. Das ist öfters der Fall, wenn eine Aufgabe modulübergreifend gelöst werden muss, und die Aufgabenkapslung für diesen Zweck aufgelöst wird.\cite{softModDes,softMdDes2,modulMitJava9,java9modRevealed,modulProgJava9}

    % Modularten wie Platform Explicit Modules, Application Explicit Modules, Automatic Modules, Open Modules, Unnamed Module 
  \section{Modularten} \label{Modularten}
    Das Modulsystem von Java unterscheidet die Module in fünf unterschiedliche Arten. Diese richten sich nach der Aufgabe und ihrer Umsetzungsstruktur. Zum Einen gibt es die JDK \textit{Plattform Module}, die die Kernfunktionalität der Java Laufzeitumgebung bieten, und Pakete wie \textit{java.lang, java.io}, \textit{java.net} mit sich bringen. Andererseits gibt es die Benutzer konstruierten \textit{Applikationsmodule}, die durch eine explizite Komposition bestimmte Aufgaben erfüllen. Beide Modultypen beinhalten eine \textit{Modulbeschreibung}, die dessen Abhängigkeiten und Schnittstellen beschreibt.\newline
    Obwohl sich mit den vorher genannten \textit{expliziten Modulen} Softwaresystemen realisieren lassen, müssen manche Module als \textit{offen} deklariert werden, um allen Nutzern während der Laufzeit den Zugriff auf den Inhalt zu gewährleisten und über Reflexion ihre Funktion nutzen zu können. Wie im Kapitel \ref{sec:refl} besprochen, ist Reflexion ein wichtiges Werkzeug in der Softwareentwicklung und wird in dem neuen Java Modulsystem unterstützt. Um ein ganzes Modul oder nur Teile des Moduls für Reflexion zu öffnen, kann entweder das ganze Modul als \textit{open module}, oder nur ein Paket als \textit{opens package.name} in der Modulbeschreibung deklariert werden. Damit hätte man ein für Reflexion offenes Modul und könnte dessen öffentlichen, sowie privaten Klassen, dynamisch aus jedem Modul auf dem Modulpfad aufrufen. Da diese Module das Konzept der starken Kapselung aufgeben, werden diese einem besonderen Typen der \textit{offenen Module} zugeordnet. \cite{modulMitJava9,java9modRevealed,modulProgJava9,explorJava9}

    \begin{figure}[h]
      \centering
      \includegraphics[width=0.7\textwidth]{material/images/module-tree.pdf}
      \caption{Modularten \cite{modulMitJava9}}
      \label{fig:modtree}
    \end{figure}

    Die nachfolgenden Modultypen sind Pseudo-Module, die für die Unterstützung der Abwärtskompatibilität eingeführt worden sind. Dementsprechend sollen diese Module eine Brücke zwischen existierender Applikation und der modularisierten Architektur bilden.\bigbreak

    Das \textit{unbenannte Modul} beschreibt alle Klassen und JAR's, die sich parallel zu der Codebasis des Modulpfades auf dem Klassenpfad befinden. Das \textit{unbenannte Modul} beschreibt somit den Legacy-Teil der Codebasis, die noch migriert werden muss, da es dies noch nicht tun kann. Daher wird mit der Bezeichnung \textit{unbenanntes Modul} eine Zugriffsbarriere zwischen der modularisierten und der legacy Architektur errichtet, die die \textit{expliziten Module} vom Zugriff auf den veralteten Klassenpfad abgrenzt. Denn dieses trägt keinen Namen und kann somit vom Entwickler nicht pragmatisch referenziert werden.\newline
    Infolgedessen entsteht eine asymmetrische Kommunikation zwischen den Architekturen. Die \textit{expliziten Module} arbeiten im neuen System auf dem Modulpfad und das \textit{unbenannte Module} darf zusätzlich neben dem klassischem Klassenpfad, ebenso auf den modernen Modulpfad zugreifen. Diese Umsetzung lässt eine inkrementelle Migration der Codebasis auf das Modulsystem zu und bleibt lauffähig, obwohl die Applikation eine interne Versionsdiskrepanz beinhaltet. \cite{modulMitJava9,java9modRevealed,modulProgJava9}

    \begin{figure}[h]
      \centering
      \includegraphics[width=0.7\textwidth]{material/images/module-access.pdf}
      \caption{Modulzugriffsrechte \cite{modulMitJava9}}
      \label{fig:modacc}
    \end{figure}

    Das letzte Modul beschreibt ein Modul mit speziellem Verhalten, das sich zwischen den Architekturen stellt und eine Brücke zwischen dem Modulpfad und dem Klassenpfad errichtet. Die \textit{automatischen Module} beschreiben einen Migrationsansatz der bestehenden Bibliotheken, die vom Klassenpfad auf den Modulpfad verschoben werden und keine \textit{Modulbeschreibung} besitzen. Diese kriegen einen Modulnamen zugewiesen und können über diesen von den \textit{expliziten Modulen} aufgerufen werden. Somit übernimmt Java die Kopplung der \textit{automatischen Module} mit allen \textit{expliziten Modulen}, indem alle internen Pakete für die Nutzung offengelegt werden und alle Module auf dem Modulpfad für die Verwendung importiert werden. Folglich ist eine Legacy-Bibliothek auf den Modulpfad funktionstüchtig und bietet eine ganz besondere Fähigkeit, nämlich die wechselseitige Kommunikation zwischen dem Modulpfad, sowie dem Klassenpfad. Dank dieser Fähigkeit können Bibliotheken migriert werden und beide Architekturen zugleich unterstützen. Dieses Verhalten motiviert die Entwickler ihren Code für den Modulpfad zu entwickeln, da die nötigen Legacy-Bibliotheken der Applikation zugleich in beiden Architekturen verfügbar ist.\newline
    Dennoch bringen die \textit{automatischen Module} zusätzliche Komplexität in die Architektur, indem alle explizite Module mit diesen verbunden werden. Daraus folgt eine starke Kopplung und somit eine unübersichtliche und starke Abhängigkeit zwischen den Modulen.\cite{modulMitJava9,java9modRevealed,modulProgJava9}\bigbreak

    Nichtsdestotrotz bietet das automatische, sowie das unbenannte Modul diverse Migrationsszenarien, die flexible Wege für die Modernisierung der Applikation anbieten.

  \section{Kopplung zwischen den Modulen} \label{sec:mod_kop}
    Die Einführung des Modulsystems in Java 9 integriert das Konzept der Aufteilung einer monolithischen Softwareumsetzung, in übersichtliche miteinander sachlich verbunden Modulen. Diese Idee wird zuerst von Java selbst umgesetzt, um als Beispiel für den aufbauenden Code zu fungieren. In der praktischen Umsetzung formuliert Java die Modulbeschreibung mithilfe der \textit{module-info.java} Datei, die drei Kopplungstypen enthalten kann: welche durch \textit{requires, exports} und \textit{opens} Deskriptoren beschrieben werden.

    \begin{figure}[h!]
      \centering
      \includegraphics[width=0.5\textwidth]{material/images/module-info.pdf}
      \caption{Die Schnittstellenbeschreibung \textit{module-info.java}}
      \label{fig:module-info}
    \end{figure}

    Die in der Abbildung \ref{fig:module-info} dargestellten und vorher diskutierten Kopplungsarten, können die Zugriffsberechtigungen ferner einschränken. Diese können ihre Schnittstelle exklusiven Modulen öffnen, die fortan als eine transitive Verbindung weiter gereicht und obendrein als eine optionale Abhängigkeit deklariert werden. Die \textit{uses} und \textit{provides} Schlüssel beschreiben eine Dienstanfrage, sowie ein Dienstangebot, die durch den Java \textit{Service-Lader} miteinender verknüpft werden.\newline
    Der \textit{Service-Lader} übernimmt in diesem Fall die Rolle des Registrierungsdienstes und vermittelt das Angebot und die Nachfrage nach Funktionalität innerhalb der Applikation. Das Konzept der Dienstregistrierung und der Dienstverwaltung geht über die Grundlagen hinaus und wird hier nicht weiter diskutiert. Dessen ungeachtet, ist es eine zusätzliche Möglichkeit die Modulkopplung zu minimieren. \cite{softModDes,modulMitJava9} \bigbreak

      \begin{figure}[h!]
      \centering
      \includegraphics[width=\textwidth]{material/images/transitiv.pdf}
      \caption{Abwandlung der Kopplungsarten}
      \label{fig:abw-kopl}
  \end{figure}

    Im Folgenden werden die in der Abbildung \ref{fig:abw-kopl} dargestellten Möglichkeiten der Kopplungstypen gelistet. Zu beachten ist die Wechselbeziehung zwischen den Modulen, die Pakete anbieten und Module anfordern. \cite{jmsOracle}

    \begin{description}
      \item[requires]\hfill
      \newline \textit{requires} Modul
      \newline \textit{requires transitiv} Modul
      \newline \textit{requires static} Modul
      \newline \textit{requires transitiv static} Modul
      \item[exports]\hfill
      \newline \textit{exports} Packet
      \newline \textit{exports} Packet \textit{to} Modul-1, Modul-2
      \item[opens]\hfill
      \newline \textit{opens} Packet
      \newline \textit{opens} Packet \textit{to} Modul-1, Modul-2
      \item [uses]\hfill
      \newline \textit{uses} Dienst-Schnittstelle 
      \item[provides]\hfill
        \newline \textit{provides} Dienst-Schnittstelle \textit{with} Service-Impl-1, Service-Impl-2
  \end{description}


  Wie in der grafischen Darstellung \ref{fig:abw-kopl} abgebildet, handelt es sich bei den Kopplungstypen um Zugriffsrechte, die als ein offener Vertrag zwischen Modulen aufgestellt werden. Dementsprechend dienen die Kopplungsschlüssel nicht nur der Lesbarkeit und Autonomie, sondern erweitern die Prozedur des Klassenladens durch explizite Schnittstellen und Zugriffsberechtigungen.\cite{modulMitJava9}

  \section{Klassenladen innerhalb der Module} \label{sec:mod-cll}
    Im Abschnitt \ref{sec:nam} wurden Namensräume vorgestellt, die Klassen von einender trennen und diese als separate Software-Komponenten behandeln, um die Sichtbarkeit der Codebasis gegenüber dem Restsystem abzugrenzen. Jedoch bring dieses Feature einen großen Aufwand mit sich. Denn sofern die Applikation eine große Anzahl an Bibliotheken benutzt und jedes davon auf einem eigenen Klassenlader betrieben werden soll, wächst der Wartungsaufwand mit der Anzahl der Bibliotheken.\newline
    Mithilfe der Module und deren neuem Ansatz der internen Kapselung, soll dieses Problem adressiert werden, indem separate Zugriffsräume für jedes Modul innerhalb eines Klassenladers definiert werden. Diesen stellen sicher, dass dass die interne Struktur eines Moduls während der Laufzeit nicht kompromittiert werden kann.\newline
    Für die Garantie der Modulkapselung, wird das im Abschnitt \ref{sec:cls} vorgestellte \textit{Java Klassenlader-System} nicht ersetzt, sondern mit zusätzlichen Kontrollen versehen, die strikt nach deklarierten Modulbeschreibung Zugriff gewährleisteten. Im Falle der Nichteinhaltung der Zugriffsrechte zwischen den Modulen, wirft der Klassenlader neue Fehlermeldungen, wie die \textit{IllegalAccessException} oder die \textit{IllegalAccessError}. Somit bleibt die ehemalige Klassenlader-Hierarchie erhalten, die an das Modulsystem von Java angepasst worden ist. \cite{classLoadingOracle, modulMitJava9}\bigbreak

    Um die neuen Kontrollmechanismen im Java Kern zu verankern, wurde die \textit{rt.jar}, die für die Ausführung von Java Code zuständig ist, auf Module mit expliziten Aufgabenbereichen aufgeteilt. Wie in der Abbildung \ref{fig:jdk} abgebildet, beschäftigt sich das aktualisierte \textit{Klassenlader-System} mit dem Laden bestimmter Module, die in Gültigkeitsbereiche fragmentiert sind. Diese nutzen immer noch das Delegierungsmodell \ref{sec:dm} und delegieren jede Anfrage zuerst an den Wurzel-Klassenlader. Mit dem Modulsystem von Java wurde dieses Verfahren durch zwei Sicherheitsverfahren erweitert. Das erste Verfahren löst eins der größten Schwierigkeiten der Java Entwickelung, nämlich das Management der Abhängigkeiten eines Systems. Diese Herausforderung wird als \textit{Jar-Hell} bezeichnet und beschreibt eine komplexe Applikation, die eine lange Liste an genutzten Drittanbieter-Bibliotheken benötigt. Hier taucht das Problem auf, dass der Applikations-Code den Klassenpfad nicht kontrolliert und annehmen muss, dass alle benötigten Bibliotheken auf den Klassenpfad vorhanden sind. Die lokal eingerichtete Maschine oder Entwicklungsumgebung kann das Management verwalten, jedoch kann diese nicht garantieren, dass die Software in einer anderen Umgebung funktionsfähig bleibt.\newline
    Dieser Anforderung hat sich das Modulsystem von Java gestellt und bietet die phasenübergreifende Wiedergabetreue auf allen Systemen, indem jedes Modul eine Voraussetzung deklariert, die der Modulpfad erfüllen muss, bevor die Applikation ihre Arbeit beginnt. Somit wird das gleiche Verhalten, sowie Fehlerprüfungen in der Kompilierungs- und Ausführungsphase erreicht.\newline
    Das zweite Verfahren garantiert die Einhaltung der Nutzungsrechte einer Bibliothek, indem die Nutzung einer Bibliothek über klar definierte Schnittstellen geschieht und unterbindet somit den impliziten Zugriff auf den Inhalt innerhalb eines Namensraums. Beide Verfahren berufen sich auf die \textit{module-info.java} Konfigurationsdatei, in der die benötigte Information verankert ist. \bigbreak

    Um die Klassen aus dem Modulpfad zu laden, wurde das \textit{Klassenlader-System} an den Modulpfad angepasst und lädt jetzt Module, die nach Sicherheitsberechtigungen bestimmten Klassenlader zugewiesen werden. Der \textit{Bootstrap}-Klassenlader ist der Klassenlader der JVM und genießt alle Sicherheitsprivilegien. Dieser lädt die \textit{Core Java-SE} und \textit{JDK-Module}, wie \textit{java.base} und \textit{java.logging}. Der Extension-Klassenlader wurde von dem Plattform-Klassenlader ersetzt und lädt jetzt die \textit{Plattform Java-SE} Module, wie zum Beispiel die \textit{java.sql}, oder die \textit{java.xml.ws} Bibliotheken. Und zuletzt bleibt der Applikation-Klassenlader, der die Applikationsmodule auf dem Modulpfad verwaltet. \cite{classLoadingOracle,modulMitJava9,java9modRevealed}

  \section{Das Modulschichten Konzept} \label{sec:module_layers}
     Obwohl das Klassenlader-Konzept von Java seine Gültigkeit behält, gibt es mit dem Einzug der modularisierten Plattform einige Änderungen.\newline 
     Mit dem Modulsystem von Java wird ein neues Konzept der Modulschichten eingeführt, das für das Laden von Java Code während der Laufzeit verantwortlich ist. Die Modulschichten kapseln, validieren und laden bestimmte Modulgruppen, die während der Laufzeit in die Applikation integriert werden können. Dazu zählen explizite, offene, sowie unbenannte Module. \newline
     Das Laden von zusätzlichem Code war bereits mit dem Klassenlader-System möglich, indem zusätzliche Klassenlader instanziiert und ausgetauscht werden konnten, jedoch besitzen die Klassenlader keine Mechanismen zum Validieren des eingelesenen Codes, sodass unerwartetes Verhalten im Betrieb der Applikation zu jedem Zeitpunkt auftreten kann. \newline
     Mithilfe der Modulschichten wird das bestehende Klassenlader-Konzept erweitert, indem zusätzliche API's für die Verwaltung von dem dynamischen Code eingeführt und das zusätzliche Erzwingen der Korrektheit der Modulabhängigkeiten innerhalb des Systems, garantiert wird.\bigbreak

    \begin{figure}[h!]
      \centering
      \includegraphics[width=0.8\textwidth]{material/images/module-graph.pdf}
      \caption{Modulgraph \cite{javaMod9}}
      \label{fig:module-graph}
    \end{figure}

     Das Laden von zusätzlichen Modulen geschieht in zwei Phasen: Zuerst wird eine Konfiguration erstellt, die ausgewählte Module für das Laden in die Applikation aufnimmt. Die Konfiguration benötigt eine Modulmenge, sowie die ausgewählte Wurzel-Module, aus den anschließend alle Modulabhängigkeiten ermittelt und validiert werden. Dafür wird ein neu eingeführtes Objekt genutzt, nämlich der \textit{Modul-Sucher}, der für ein gegebenes Verzeichnis die Metainformationen aller Module ausliest und für die Nutzung bereitstellt. \newline
     Im nächsten Schritt müssen die gefundenen Module auf Konsistenten geprüft werden. Dazu wird ein Modul Graph \ref{fig:module-graph} erzeugt, der aus den gegebenen Wurzel-Modulen alle geforderten Modulbeziehungen auflöst. Er inspiziert \textit{Split Packages}, \textit{Zyklen}, valide Zugriffsrechte und erklärt im Anschluss den Code für ausführbar. Dieser stellt sicher, dass alle Abhängigkeiten, einschließlich der indirekten Abhängigkeiten, aufgelöst werden können.\newline
     Das Ergebnis besteht aus einer betriebsfähigen Konfiguration mit einer Strukturgrafik der aufgelösten Abhängigkeiten, die für die Ausführung im Applikationskontext benötigt wird. \cite{java9modRevealed}\bigbreak 

    \begin{figure}[h!]
      \centering
      \includegraphics[width=\textwidth]{material/images/module-layer.pdf}
      \caption{Modulschicht \cite{javaMod9}}
      \label{fig:module-layer}
    \end{figure}

    Nachdem die Konfiguration ausgewertet wurde, kann eine Modulschicht erstellt werden, die alle Module der konsistenten Konfiguration instanziiert. Dafür wird ein neuer Klassenlader von der Modulschicht erstellt und eine Hierarchie aufgebaut, die auf meherere übergeordnete Modulschichten, sowie einen Klassenlader verweist. Dementsprechend referenziert der Modulschicht-Klassenlader immer auf einen übergeordneten Klassenlader, um dem ehemaligen Delegierungsmodell zu entsprechen und die Funktionalität der \textit{unbenannten Module} weiterhin erfüllen zu können. Des Weiteren, referenziert die Modulschicht selbst auf eine variable Menge von übergeordneten Modulschichten, die das Auflösen der benötigten benannten Modulabhängigkeiten unterstützen und die Modulsuche an entsprechenden Modulschichten weiterleitet. \bigbreak

    Das neue Konzept der Modulschichten erweitert das bestehende System der selbst erstellten hierarchischen Namensräume, indem Modulabhängigkeiten beim Laden in die Applikation validiert, gruppiert und aktiv verwaltet werden können. Darüber hinaus enthält die Modulschicht-Konfiguration die komplette Information über den Inhalt ihrer Schicht, sowie der darunterliegenden Modulschichten. \newline
    Die Konfiguration von dem dynamisch nachgeladenen Code, der Schichtübergreifend validiert wird, verhindert das Überlagern des bereits integrierten Codes und ändert die Art und Weise, wie die Suche nach Modulklassen durchgeführt wird. \newline
    Die Klassensuche wird nun mit der \textit{direkten Delegation} durchgeführt, die zuerst die eigene Schicht bevorzugt, bevor die Anfrage an die darüberliegende Schicht weiterleitet wird. Die übergeordnete Schicht verhält sich nach demselben Prinzip und versucht zuerst selbst die Klasse zu laden, bevor die nächste Delegation durchgeführt wird. \bigbreak

    Kurzgefasst, gehören Schichten zu Modulen wie Klassenlader zu Klassen; also ein Mechanismus zum Laden und Instanziieren von Elementen mit erweiterten Diensten und Sicherheitsbestimmungen.\cite{javaMod9,parentDelegationModel,modulMitJava9}

  \section{Der Service-Lader} \label{sec:servLoad} 
    Die Java Version 1.6 führt ein Konzept der Dienste ein, die eine bessere Entkopplung zwischen Klassen unterstützt, indem Klassenabhängigkeiten erst zur Laufzeit aufgelöst werden können. Dadurch wird eine Entkopplung zwischen den Anbieter-Klassen und den später auf diese zugreifenden Nutzer-Klassen erreicht, indem die Klassenbindung nicht über eine direkte Implementierung, sondern über eine Schnittstelle umgesetzt wird. Über den \textit{Service-Lader} kann anschließend auf die einzelne Implementierung-Instanz zugegriffen werden. \bigbreak
    \begin{figure}[h!]
      \centering
      \includegraphics[width=0.8\textwidth]{material/images/ServiceLoadingMulti.pdf}
      \caption{Service-Lader Konzept}
      \label{fig:serviceLoaderMulti}
    \end{figure}
    Die Dienst–Anbieter und Dienst-Nutzer lassen sich in der \textit{module-info.java} Konfigurationsdatei definieren und zur Laufzeit lässt sich die Implementierung eines bestimmten Dienstes von der Applikation wählen, ohne dass zuvor eine explizite Abhängigkeit zwischen diesen Modulen deklariert wurde. \bigbreak

    Der Java \textit{Service-Lader} spielt eine wichtige Rolle für die Entkopplung der Module. Dieser sucht  Applikation nach angebotenen Diensten für eine entsprechende Schnittstelle ab, und versorgt den Nutzer mit einer möglichen Umsetzung. Somit können mehrere gleiche oder unterschiedliche Dienste in der Applikation existieren und vom Nutzer entkoppelt, abgefragt und ausgeführt werden. Dafür wird in der \textit{module-info.java} mit den \textit{provides with} und \textit{uses} Schlüssel die Dienstkommunikation etabliert und über den \textit{Service-Lader} umgesetzt. Somit dient die \textit{Service-Lader} Instanz innerhalb der Applikation als ein Registrierungsdienst.\bigbreak


    In der Abbildung \ref{fig:serviceLoaderMulti} ist ein Nutzermodul abgebildet, welches ein Dienst des Schnittstellen-Moduls anfordert. Die Suche nach einem Dienst für die angefragte Schnittstelle, übernimmt der \textit{Service-Lader} und instaziiert eine Liste an möglichen Anbietern. Der Nutzer kann anschließend entscheiden, welche Implementation er nutzen möchte.   


\section{Der modularisierte JDK} \label{sec:modular_java_base}
  Um die aufgestellten Regeln und Konzepte des entworfenen Modulsystems in Java zu integrieren, muss die Java Plattform diese selbst als Vorreiter erfüllen. \bigbreak
  Demnach wurde die Laufzeitumgebung (\textit{Run-Time}), die aus der \textit{rt.jar} besteht, auf Module aufgeteilt und miteinander über Kommunikationsregeln und Schnittstellen verknüpft. Das Ergebnis der modularisierten \textit{rt.jar} ergab 70 Module, die sich gegenseitig ergänzen. \newline
  In der Konsequenz ist eine kleine Applikation, die sich nur an dem \textit{base} Modul bedient, mit einem Speicherbedarf von 16 MB umsetzbar. Im Gegensatz dazu, müssten für ein paar Zeilen Code in der 8 Version von Java, 160 MB der \textit{rt.jar} in die Laufzeitumgebung miteinbezogen werden, um den Laufzeitanforderungen zu entsprechen.\bigbreak
  \begin{figure}[h!]
   \centering
   \includegraphics[width=\textwidth]{material/images/moduleGraph.jpg}
   \caption{Modularisierte \textit{rt.jar} Laufzeitumgebung \cite{modGraph}}
   \label{fig:jdk}
  \end{figure}
  Obwohl das Modulsystem viele Neuerungen und Aufwertungen der Java Plattform mit sich brachte, konnten nicht alle Wünsche erfüllt werden. Wie zum Beispiel das Nutzen gleichnamiger Bibliotheken mit unterschiedlicher Versionsnummer.\newline
  Dennoch gibt es Ansätze, die es erlauben, eine Versionsnummer in einem Modul zu verankern und somit existiert die Wahrscheinlichkeit, dass diese Fähigkeit in der Zukunft nachgerüstet wird. 
 

