\chapter{Einleitung}
\pagenumbering{arabic}

\section{Verteilte Systeme}

	Fast alle informationstechnischen Anwendungen und Systeme sind heutzutage verteilt, da die Ansprüche an die Rechenleistung ständig wachsen und mit heutigen Mitteln, durch einen Rechenknoten kaum noch zu bewältigen sind. \bigbreak

	Zu den wesentlichen Aufgabestellungen der verteilten Systeme, gehören Konzepte wie Parallelität, Synchronisation, Kommunikation, Kooperation, Koordination und Sicherheit. Diese Aspekte bringen ein hohes Maß an Komplexität mit sich, denn diese müssen alle zugleich auf eine elastische Menge an Knoten angewandt werden und die gegebenen Aufgaben sowohl zielgerichtet als auch ausfallsicher, erfüllen. Daher gibt es einen hohen Bedarf an Ansätzen, die eine sinnvolle, robuste und übersichtliche Organisation der verteilten Systeme umsetzen. \bigbreak

	Zu diesem Zeitpunkt werden die meisten verteilten Systeme durch eine Spezifikation definiert, die aus Szenarien und lokalen Aktionen besteht. Diese bilden jedoch keine Möglichkeit, das gesamte Modell formal einheitlich zu analysieren und darzustellen. Diesem Problem widmen sich die Petri-Netzansätze, die eine einheitliche Darstellung globaler und lokaler Aspekte, sowie die Kommunikation in dem verteilten System versprechen. \cite{ochsenschlager2013modellierung}

\section{Kontext der Petri-Netze} \label{sec:KdP} 

	Das Konzept der Nebenläufigkeit wurde in der Arbeit von \textit{Carl Adam Petri} verfasst. Die Dissertation von \textit{Carl Adam Petri} \cite{Petr} beschreibt das Grundprinzip der Synchronisation von endlichen Automaten und bildet die Basis für das Konzept der Petri-Netze. Die Petri-Netze bestehen aus Stellen, Marken, Kanten und Transitionen, die nebenläufige und kommunizierende Prozesse darstellen können. Der ursprüngliche S/T-Netz \cite{Jess} Formalismus wurde mit der Zeit durch gefärbte Marken erweitert, mit dem Ziel äquivalente, Strukturen zusammenzufassen und die darin befindlichen Marken zu typisieren \cite{Kummer02}. Da die Struktur des Netzes immer noch stark zusammenhängend ist, bleibt die Organisation des Netzes schwer verständlich für das menschliche Auge.\bigbreak

	Demzufolge sollte das Netz auf logische und zusammenhängende Komponenten aufgeteilt werden und trotzdem als ein Ganzes gelten. Diese Anforderung wird von den synchronen Kanälen umgesetzt, indem die Netzkomponenten anstelle der Kanten mit synchronen Kanälen verbunden werden. So werden diese gezwungen, die miteinander verbunden Transitionen synchron zu schalten \cite{Kummer02}. Hiermit ist eine Trennung des Netzes nach ihrer Funktionalität erreicht, die qualitativ anspruchsvolle Modelle komplexer und verteilter Systeme entwerfen lässt.\bigbreak

	Obwohl das gefärbte Petri-Netz ein anspruchsvolles Modellierungswerkzeug bietet, bleibt das gesamte Netzwerk statisch. Demzufolge wurde der nächste Evolutionsschritt in der Entwicklung der Petri-Netze mit dem Referenznetz-Formalismus von Rüdiger Valk getan \cite{Valk09}. Der Referenznetz-Formalismus erlaubt dynamisch Netzinstanzen zu erstellen und diese als Marken in einem anderen Netz zu bewegen. Somit kann es mehrere Instanzen eines Netzes geben, die mit unterschiedlicher Belegung im Petri-Netz existieren \cite{Kummer02}.

% Interesante Teile der Verteilten Modelierung in \textsc{Renew} 
\section{Ein Petri-Netz Simulator} \label{sec:EPS}

	\textsc{Renew} ist ein Petri-Netz Simulator, der die oben genannten Petri-Netz Formalismen unterstützt. Dieser ist in Java geschrieben und bietet eine Oberfläche zum Zeichnen und einen Simulator zum Ausführen der Netze \cite{Kummer+99a}.\bigbreak

	Da die ursprüngliche Umsetzung von Olaf Kummer auf Komponenten beruhte, mussten die Komponenten während der Kompilationszeit hinzugefügt werden, um den anschließenden Betrieb aufnehmen zu können. Somit konnten die \textsc{Renew} Komponenten nach dem Kompilieren nicht mehr ausgetauscht werden.\newline
	Demzufolge musste genau darauf geachtet werden, welche Komponenten mitkompilliert werden, um eine bestimmte \textsc{Renew} Funktion nutzen zu können. Somit setzte die Nutzung von \textit{Renew} viel Fachwissen voraus, um die passenden Komponenten sinnvoll zu kompilieren und zu betreiben. \newline 
	Nachfolgend wurden die Komponenten mit einem Lebenszyklus und einer Kontrollinstanz erweitert, um während der Laufzeit die Komponenten miteinander zu verknüpfen, und die Funktionalität von \textsc{Renw}, ohne eine Rekompilation anzupassen. Die sogenannte Plugin-Architektur wurde von Jörn Schumacher \cite{Schumacher03} eingeleitet und anschließend von Duvigneau \cite{Duvigneau09} weitergeführt.\newline
	Die Plugin-Architektur von \textit{Renew} erlaubt das Ausführen variabler Plugin-Mengen, die beim Start der Applikation angegeben werden können. Des Weiteren ist das Nachrüsten von Funktionen während der Laufzeit möglich, indem zusätzliche Plugins von dem Plugin-Manager eingelesen und in die Applikation integriert werden. Der Plugin-Manager ist die zentrale Instanz und erstellt beim Start der Applikation zwei primäre Namensräume, die die Drittanbieter-Bibliotheken und die Plugins voneinander trennen und sie separat verwalten lassen \cite{Duvigneau09}.

\section{Motivation} \label{sec:motivation1}
	Aufgrund der langen Entwicklungszeit von \textsc{Renew}, ist eine Überarbeitung notwendig. Dies kann an den Codestellen abgelesen werden, die zum Teil aus der JDK 1.4 Version stammen. Somit entsprechen die erstmaligen Gestaltungsmöglichkeiten, Architekturentscheidungen und ihre Umsetzungen, nicht mehr dem aktuellen Stand der Technik. Vor allem durch die Einführung des Modulsystems von Java, mit dem der JDK, sowie der darauf aufbauende Code modularisiert wird, ist der Betrieb von \textsc{Renew} in der Zukunft gefährdet. Im Zuge dessen ist das Portieren der Applikation unvermeidlich und trägt ein gewisses Risiko mit sich.

\section{Fragestellung} \label{sec:KdS}
	Es ist unklar, wie sich die benutzerdefinierten Namensräume und die so gut wie unberührten Kern-Plugins, auf die neue Modulstruktur übertragen lassen. Denn die Suche nach dem zusätzlichen Plugin-Code stellt eine zentrale Funktion im System dar.\newline
	Darüber hinaus führt Java neue Konzepte ein, die das dynamische Verwalten der Codebasis ermöglichen. Somit könnte das Plugin Management von \textit{Renew} von den neuen Features profitieren. \bigbreak
	Bei flüchtiger Beurteilung verfügt \textit{Renew} über mehrere Schwachstellen, die das Arbeiten mit der Plugin Verband erschweren. Dazu zählt die Build-Umgebung von \textsc{Renew} oder die Software Entwicklung von nicht erfahrenen Studierenden, zumal die Ant-Build-Umgebung zusammen mit \textsc{Renew} in die Jahre gekommen ist und bestimmte obligatorische Funktionalität der modernen Software Entwicklung nicht unterstützt. Des Weiteren führt die exzessive Verknüpfung der Plugins untereinander zu Problemen in der Verständlichkeit der Plugin-Abhängigkeiten.\bigbreak

	Beifolgend stellen sich die Fragen: Wie relevant sind die neu eingeführten Java Features für \textsc{Renew} und was muss beachtet werden, damit der Umstieg von \textsc{Renew} auf das Modulsystem von Java gelingt.

% Welche Ziele ergeben sich, welches suche ich mir aus 
\section{Ziel} \label{sec:Z}
	Das Ziel dieser Arbeit ist die Anpassung von \textsc{Renew} an die neuen Anforderungen der Java Laufzeitumgebung, sodass eine minimale und anschließend eine erweiterbare Version von \textsc{Renew} entsteht, die letztendlich ein Teil des \textsc{Mulan} Rahmenwerks unterstützt. Dafür wird eine moderne Build-Umgebung eingerichtet, die das Modulsystem unterstützt, um anschließend eine modulare \textsc{Renew} Version aufzusetzen. Darüber hinaus werden neu eingeführte Konzepte des Modulsystems auf den möglichen Einsatz in \textsc{Renew} untersucht. \newline
	Der Zweck dieser Arbeit ist, eine Struktur bereitzustellen, die eine moderne und nachhaltige Basis der \textsc{Renew} Applikation anfertigt, um den Entwicklern einen unkomplizierten Einstieg in die existierende Logik zu ermöglichen, sowie die Entwickler-Fähigkeiten in der Forschung verteilter Systeme, zu unterstützen.\bigbreak

\section{Aufbau der Arbeit} \label{sec:AdA}
	Die Abschlussarbeit beginnt mit der Einleitung der Grundlagen, die das Arbeiten mit Java näherbringt. Dazu gehören Konzepte wie der Klassenpfad, Klassenlader und Reflexion, die in der Umsetzung von \textsc{Renew} eine wichtige Rolle spielen. Anschließend werden aufbauende Entwurfsmuster und Prozeduren des Modulsystems von Java erläutert, die das bestehende Java-System aktualisieren und neue Konzepte integrieren. Zum Schluss der Grundlagen werden Migrationsansätze gängiger Arten und eine Übersicht der gängiger Szenarien vorgestellt\newline
	Das nachfolgende Kapitel der Ausgangssituation beschäftigt sich mit der Motivation der Arbeit, den daraus folgenden Zielen, sowie Rahmenbedingungen. Darüber hinaus werden Auswirkungen des Modulsystems von Java und Gradle auf \textsc{Renew} erarbeitet, die \textsc{Renew} unterstützen und erweitern. Zusätzlich wird in diesem Kapitel der aktuelle Zustand der \textsc{Renew} Applikation beschrieben, der als Basis für die Prototypen dienen soll. \bigbreak 

	Als Teil der Umsetzung entstehen drei Prototypen. Der erste Prototyp rekonstruiert die ausgewählten Teile von \textsc{Renew} modular, um die neue eingeführten Features des Modulsystems nutzen zu können. Der zweite Prototyp baut auf der entstandenen modularen \textit{Renew}-Umsetzung auf und demonstriert den Parallelbetrieb von modularem und nicht modularem Code. Zum Schluss demonstriert der dritte Prototyp eine mögliche Umsetzung des dynamischen Ladens der Plugins mithilfe des Modulsystems.\newline
	Demzufolge wird die Codebasis von \textsc{Renew} und \textsc{Mulan} bei Bedarf modernisiert und auf das Modulsystem von Java angepasst. Dabei soll der Schwerpunkt dieser Arbeit beim Erarbeiten einer modularen \textsc{Renew}-Umsetzung liegen und demnach Plugins in erweiterbare Java Module transformieren.\newline
	Dafür wird die bestehende Projektkonstruktion reorganisiert, sodass Plugins durch mehrere Module repräsentiert wenden können. Darauf aufbauend müssen Plugins die Moduleigenschaften einhalten und die entsprechenden Regeln und Konfigurationen erfüllen. Und zum Schluss wird die \textsc{Renew} Applikation mit einem modernen \textit{Build}-Werkzeug organisiert und für die Ausführung verpackt.\newline
	Das Ergebnis soll das Modularisierungskonzept in jedem Abschnitt des Lebenszyklus von \textsc{Renew} unterstützen. Daher wird erwartet, dass beim Entwickeln, beim Kompilieren, beim Verpacken und beim Ausführen der Applikation, das modulare Denken befolgt wird. \bigbreak

	Das Ergebnis soll als Grundlage für den nächsten Lebenszyklus von \textsc{Renew} dienen und die Entwicklung einfach, flexibel und erweiterbar gestalten. %Dafür wird die Unterstützung von \textsc{Mulan} benötigt, das die wesentlichen Funktionen von \textsc{Renew} voraussetzt. 
