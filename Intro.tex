\chapter{Einleitung}
\pagenumbering{arabic}

\section{Verteilte Systeme}

	Fast alle informationstechnischen Anwendungen und Systeme sind heutzutage verteilt, da die Ansprüche an Rechenleistung ständig wächst und mit heutigen Mitteln, durch einen Rechenknoten kaum zu bewältigen sind. \bigbreak
	Zu den wesentlichen Aufgabestellungen der verteilten Systeme, gehören Konzepte wie Parallelität, Synchronisation, Kommunikation, Kooperation, Koordination und Sicherheit. Diese Aspekte bringen ein hohes Maß an Komplexität mit sich, denn diese müssen alle zugleich auf eine elastische Menge an Knoten angewandt werden und die gegebenen Aufgaben zielgerichtet ebenso ausfallsicher erfüllen. Daher gibt es einen hohen Bedarf nach Ansätzen, die eine sinnvolle, robuste und übersichtliche Organisation der verteilten Systeme umsetzen. \bigbreak
	Zu diesen Zeitpunkt werden die meisten verteilten Systeme durch eine Spezifikation definiert, die aus Szenarien und lokale Aktionen besteht. Diese bilden jedoch keine Möglichkeit das gesamte Modell formal einheitlich zu analysieren und darzustellen. Diesem Problem widmen sich die Petrinetz Ansätze, die eine einheitliche Darstellung globaler und lokaler Aspekte sowie der Kommunikation in dem verteilten System versprechen. \cite{ochsenschlager2013modellierung}

\section{Kontext der Petrinetze} \label{sec:KdP} 

	Das Konzept der Petrinetze wurde in der Arbeit von \textit{Carl Petri} beschrieben. Dieses besteht aus Stellen, Marken, Kanten und Transitionen, die nebenläufige und kommunizierende Prozesse darstellen können. Der ursprüngliche S/T-Netz Formalismus wurde mit der Zeit durch gefärbten Marken erweitert, mit dem Ziel äquivalente Strukturen zusammenzufassen und die darin befindlichen Marken zu typisieren \cite{kummerReferenznetze}. Da die Struktur des Netzes immer noch stark zusammenhängend ist, bleibt die Organisation des Netzes schwer verständlich für das menschliche Auge.\bigbreak

	Demzufolge sollte des Netzes auf logisch zusammenhänge Komponente aufgeteilt werden und trotzdem als ein Ganzes gelten. Diese Anforderung wird von den synchronen Kanälen umgesetzt, indem die Netzkomponenten anstelle der Kanten mit synchronen Kanälen verbunden werden und zwingen die mit einander verbunden Transitionen synchron zu schalten \cite{kummerReferenznetze}. Hiermit ist eine Trennung des Netzes nach ihrer Funktionalität erreicht, die qualitativ anspruchsvolle Modelle komplexer und verteilter Systeme entwerfen lässt.\bigbreak

	Obwohl das erweiterte Petrinetz anspruchsvolle Modellierungswerkzeug bietet, bleibt das gesamte Netzwerk statisch. Demzufolge wurde der nächste Evolutionsschritt in der Entwicklung der Petrinetze mit den Referenznetz Formalismus getan. Dieser erlaubt dynamisch und bei Bedarf Netzinstanzen zu erstellen und diese als Marken in einem anderen Netz zu bewegen. Somit kann es mehrerer Instanzen eines Netzes geben, die mit unterschiedlicher Belegung im Petrinetz existieren \cite{kummerReferenznetze}.

% Interesante Teile der Verteilten Modelierung in Renew 
\section{Ein Petrinetz Simulator} \label{sec:EPS}

	Renew ist ein Petrinetz Simulator, der die oben genannten Petrinetz Formalismen unterstützt. Dieser ist in Java geschrieben und bietet eine Oberfläche zum Zeichnen und einen Simulator zum Ausführen der Netze \cite{userGuide}.\bigbreak

	Da die ursprüngliche Umsetzung von Olaf Kummer eine empfindliche, monolithische Architektur besaß und viel Fachwissen voraussetzte, wurde diese zu einem Plugin Verband von Jörn Schumacher zu Gunsten der Robustheit und Erweiterung unstrukturiert \cite{schummacher}. Ab diesen Punkt kann Renew über die Plugin Schnittstellen erweitert werden, ohne die existierende Logik zu beeinflussen.\bigbreak

	Mit seiner Umsetzung delegierte Jörn Schumacher die Ausführung von Logik an Plugins und erstellte eine zentrale Instanz, die den Lebenszyklus bekannter Plugins verwaltet und koordiniert. Die zentrale Instanz nennt sich Plugin-Manager und kann das Verhalten von Renew mithilfe der Plugins modifizieren. Der Plugin-Manager baut auf zwei primären Namensräume auf. Zum einen braucht dieser zusätzlichen Bibliotheken zum verwalten seiner Umgebung und zum anderen braucht er Plugins, die Funktionalität mit sich bringen \cite{douvigneau}.

% Fragestellungen
\section{Konstellation des Simulators} \label{sec:KdS}

	Mit der Plugin Architektur hat Renew den Lebenszyklus weit überschritten. Dies kann an den Codestellen abgelesen werden, die zum Teil aus der JDK 1.4 Version stammen. Somit entsprechen die erstmaligen Gestaltungsmöglichkeiten, Architekturentscheidungen und ihre Umsetzung, nicht mehr den aktuellen Stand der Technik. Vor allem durch die Einführung des Modulsystem von Java, mit dem der JDK sowie der darauf aufbauende Code modularisiert wird, ist der Betrieb von Renew in der Zukunft gefährdet. Im Zuge dessen ist das Portieren der Applikation unvermeidlich und trägt ein gewisses Risiko mit sich. Es ist unklar wie sich die benutzerdefinierten Namensräume und die so gut wie unberührten Kern-Plugins auf die neuen Modulstruktur übertragen lassen. Zumal die Suche nach zusätzlichen Plugin Code eine zentrale Funktion in System vertretet.\newline
	Als zusätzliche mögliche Schwachstellen der Renew Applikation, kann die Build-Umgebung von Renew oder unsaubere Software Entwicklung von nicht erfahrenen Studenten auftreten. Zumal die Build-Umgebung zusammen mit Renew in die Jahre gekommen ist und bestimmte obligatorische Funktionen der modernen Software Entwicklung nicht besitzt und das Konzept der Delegation der Plugin Architektur, zu Code-Duplizierung und Problemen in der Verständlichkeit der Plugin-Abhängigkeiten führt.\bigbreak

	Beifolgend stellt sich die Frage: Wie portierbar ist Renew und was muss beachtet werden, damit der Umstieg auf das Modulsystem von Java gelingt.

% Welche Ziele ergeben sich, welches suche ich mir aus 
\section{Ziel} \label{sec:Z}

	Das Ziel dieser Arbeit ist die Anpassung von Renew an die neuen Anforderungen der Java Laufzeitumgebung, sodass eine minimal und anschließend eine erweiterte Version von Renew entsteht, die schlussendlich ein Teil des \textit{Mulan} Rahmenwerks unterstützt. Dafür wird eine moderne Build-Umgebung eingerichtet die das Modulsystem unterstützt, um anschließend eine modulare Renew Version aufzusetzen. 
	Der Zweck dieser Arbeit ist eine Struktur, die einen modernen und nachhaltigen Zustand der Renew Applikation anfertigt, um den Entwickler einen unkomplizierten Einstieg in die existierende Logik zu ermöglichen, sowie die Entwickler-Fähigkeiten in der Forschung verteilter Systeme voranzutreiben.\bigbreak

\section{Aufbau der Arbeit} \label{sec:AdA}
	Die Abschlussarbeit beginnt mit der Einleitung der Grundalgen, die das Arbeit mit Java näher bringt. Dazu gehören Konzepte wie der Klassenpfad, Classloader und Reflection, die in der Umsetzung von Renew eine wichtige Rolle spielen. Anschließend werden aufbauende Entwurfsmuster und Prozeduren des Modulsystem von Java erläutert, die das bestehende Java System aktualisieren und neue Konzepte integrieren. Zum Schluss der Grundlagen werden Migrationsansätze vorgestellt, die gängigen Migrationsarten abdecken und eine Übersicht über die möglichen Migrationsszenarien vorstellen.\newline 
	Das nachfolgende Kapitel der Ausgangssituation beschäftigt sich mit der Motivation der Arbeit, den daraus folgenden Zielen sowie Rahmenbedingungen. Zusätzlich wird in diesem Kapitel der aktuelle Zustand der Renew Applikation erarbeitetet, der als Basis für die Prototypen dienen soll. \bigbreak 

	Als Teil der Umsetzung entstehen zwei Prototypen, die ausgewählte Teile von Renew modular restrukturieren. Demzufolge wird die Codebasis sowie Design Entscheidungen bei Bedarf modernisiert und auf das Modulsystem von Java angepasst. Dabei soll der Schwerpunkt dieser Arbeit beim Erarbeiten einer modularen Renew Umsetzung liegen und demnach Plugins in erweiterbare Java Module transformieren.\newline
	Dafür wird die bestehende Projekt Konstruktion reorganisiert, sodass Plugins durch mehrere Module repräsentiert wenden können. Darauf aufbauend müssen Plugins die Moduleigenschaften einhalten und die entsprechenden Regeln und Konfigurationen erfüllen. Und zum Schluss wird die Renew Applikation mit einem modernen \textit{build} Werkzeug organisiert und für die Ausführung verpackt.\newline
	Das Ergebnis soll den Modularisierungskonzept in jedem Abschnitt des Lebenszyklus von Renew unterstützen. Daher wird erwartet, dass das modulare Denken in der Entwicklungsumgebung beim Entwickeln, beim Kompilieren und Verpacken sowie beim Ausführen der Applikation integriert wird. \bigbreak

%todo 
	Das Ergebnis soll als Grundlage für die nächste Lebenszyklus von Renew dienen und die Entwicklung einfach, flexible und erweiterbar gestalten. Dafür wir die Unterstützung von \textit{Mulan} benötigt, welches die wesentliche Funktion von Renew voraussetzt. 
