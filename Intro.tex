\chapter{Einleitung}
\pagenumbering{arabic}

\section{Verteilte Systeme}

	Fast alle informationstechnischen Anwendungen und Systeme sind heutzutage verteilt, da die Ansprüche an die Rechenleistung ständig wachsen und mit heutigen Mitteln, durch einen Rechenknoten kaum noch zu bewältigen sind. \bigbreak

	Zu den wesentlichen Aufgabestellungen der verteilten Systeme, gehören Konzepte wie Parallelität, Synchronisation, Kommunikation, Kooperation, Koordination und Sicherheit. Diese Aspekte bringen ein hohes Maß an Komplexität mit sich, denn diese müssen alle zugleich auf eine elastische Menge an Knoten angewandt werden und die gegebenen Aufgaben zielgerichtet ebenso wie ausfallsicher erfüllen. Daher gibt es einen hohen Bedarf nach Ansätzen, die eine sinnvolle, robuste und übersichtliche Organisation der verteilten Systeme umsetzen. \bigbreak

	Zu diesem Zeitpunkt werden die meisten verteilten Systeme durch eine Spezifikation definiert, die aus Szenarien und lokale Aktionen besteht. Diese bilden jedoch keine Möglichkeit das gesamte Modell formal einheitlich zu analysieren und darzustellen. Diesem Problem widmen sich die Petrinetz Ansätze, die eine einheitliche Darstellung globaler und lokaler Aspekte sowie die Kommunikation in dem verteilten System versprechen. \cite{ochsenschlager2013modellierung}

\section{Kontext der Petrinetze} \label{sec:KdP} 

	Das Konzept der Petrinetze wurde in der Arbeit von \textit{Carl Petri} beschrieben. Dieses besteht aus Stellen, Marken, Kanten und Transitionen, die nebenläufige und kommunizierende Prozesse darstellen können. Der ursprüngliche S/T-Netz Formalismus wurde mit der Zeit durch gefärbte Marken erweitert, mit dem Ziel äquivalente Strukturen zusammenzufassen und die darin befindlichen Marken zu typisieren \cite{Kummer02}. Da die Struktur des Netzes immer noch stark zusammenhängend ist, bleibt die Organisation des Netzes schwer verständlich für das menschliche Auge.\bigbreak

	Demzufolge sollte das Netzes auf logisch zusammenhänge Komponente aufgeteilt werden und trotzdem als ein Ganzes gelten. Diese Anforderung wird von den synchronen Kanälen umgesetzt, indem die Netzkomponenten anstelle der Kanten mit synchronen Kanälen verbunden und gezwungen die mit einander verbunden Transitionen synchron zu schalten \cite{Kummer02}. Hiermit ist eine Trennung des Netzes nach ihrer Funktionalität erreicht, die qualitativ anspruchsvolle Modelle komplexer und verteilter Systeme entwerfen lässt.\bigbreak

	Obwohl das erweiterte Petrinetz ein anspruchsvolles Modellierungswerkzeug bietet, bleibt das gesamte Netzwerk statisch. Demzufolge wurde der nächste Evolutionsschritt in der Entwicklung der Petrinetze mit dem Referenznetz Formalismus getan. Dieser erlaubt dynamisch und bei Bedarf Netzinstanzen zu erstellen und diese als Marken in einem anderen Netz zu bewegen. Somit kann es mehrerer Instanzen eines Netzes geben, die mit unterschiedlicher Belegung im Petrinetz existieren \cite{Kummer02}.

% Interesante Teile der Verteilten Modelierung in \textsc{Renew} 
\section{Ein Petrinetz Simulator} \label{sec:EPS}

	\textsc{Renew} ist ein Petrinetz Simulator, der die oben genannten Petrinetz Formalismen unterstützt. Dieser ist in Java geschrieben und bietet eine Oberfläche zum Zeichnen und einen Simulator zum Ausführen der Netze \cite{Kummer+99a}.\bigbreak

	Da die ursprüngliche Umsetzung von Olaf Kummer eine empfindliche, monolithische Architektur besaß und viel Fachwissen voraussetzte, wurde diese zu einem Plugin Verband von Jörn Schumacher zu Gunsten der Robustheit und Erweiterung unstrukturiert \cite{Schumacher03}. Ab diesen Punkt kann \textsc{Renew} über die Plugin Schnittstellen erweitert werden, ohne dass die existierende Logik beeinflusst wird.\bigbreak

	Mit seiner Umsetzung delegierte Jörn Schumacher die Ausführung von Logik an Plugins und erstellte eine zentrale Instanz, die den Lebenszyklus bekannter Plugins verwaltet und koordiniert. Die zentrale Instanz nennt sich Plugin-Manager und kann das Verhalten von \textsc{Renew} mithilfe der Plugins modifizieren. Der Plugin-Manager baut auf zwei primären Namensräumen auf. Zum einen braucht dieser zusätzlichen Bibliotheken zum Verwalten seiner Umgebung und zum anderen braucht er Plugins, die Funktionalität mit sich bringen \cite{Duvigneau09}.

\section{Motivation} \label{sec:motivation}
	Mit der Plugin Architektur hat \textsc{Renew} den Lebenszyklus weit überschritten. Dies kann an den Codestellen abgelesen werden, die zum Teil aus der JDK 1.4 Version stammen. Somit entsprechen die erstmaligen Gestaltungsmöglichkeiten, Architekturentscheidungen und ihre Umsetzung, nicht mehr den aktuellen Stand der Technik. Vor allem durch die Einführung des Modulsystem von Java, mit dem der JDK sowie der darauf aufbauende Code modularisiert wird, ist der Betrieb von \textsc{Renew} in der Zukunft gefährdet. Im Zuge dessen ist das Portieren der Applikation unvermeidlich und trägt ein gewisses Risiko mit sich.

\section{Fragestellung} \label{sec:KdS}
	Es ist unklar wie sich die benutzerdefinierten Namensräume und die so gut wie unberührten Kern-Plugins auf die neuen Modulstruktur übertragen lassen. Zumal die Suche nach dem zusätzlichen Plugin Code eine zentrale Funktion in System darstellt.\newline
	Darüber hinaus führt Java neue Konzepte ein, die das dynamische Verwalten der Codebasis ermöglichen. Somit könnte das Plugin Management von \textit{Renew} von den neuen Features profitieren. \bigbreak
	Bei flüchtiger Beurteilung verfügt \textit{Renew} über mehrere Schwachstellen, die das Arbeiten mit der Plugin Verband erschweren. Dazu zählt die Build-Umgebung von \textsc{Renew} oder schwammige Software Entwicklung von nicht erfahrenen Studenten. Zumal die Build-Umgebung zusammen mit \textsc{Renew} in die Jahre gekommen ist und bestimmte obligatorische Funktionen der modernen Software Entwicklung nicht besitzt. Des Weiteren führt die exzessive Verknüpfung der Plugins untereinander zu Problemen in der Verständlichkeit der Plugin-Abhängigkeiten führt.\bigbreak

	Beifolgend stellen sich die Fragen: Wie relevant sind die neu eingeführten Java Features für \textsc{Renew} und was muss beachtet werden, damit der Umstieg von \textsc{Renew} auf das Modulsystem von Java gelingt.

% Welche Ziele ergeben sich, welches suche ich mir aus 
\section{Ziel} \label{sec:Z}

	Das Ziel dieser Arbeit ist die Anpassung von \textsc{Renew} an die neuen Anforderungen der Java Laufzeitumgebung, sodass eine minimal und anschließend eine erweiterte Version von \textsc{Renew} entsteht, die schlussendlich ein Teil des \textsc{Mulan} Rahmenwerks unterstützt. Dafür wird eine moderne Build-Umgebung eingerichtet, die das Modulsystem unterstützt, um anschließend eine modulare \textsc{Renew} Version aufzusetzen. Darüber hinaus werden neu eingeführte Konzepte des Modulsystem auf den möglichen Einsatz in \textsc{Renew} untersucht. \newline
	Der Zweck dieser Arbeit ist eine Struktur, die einen moderne und nachhaltige Basis der \textsc{Renew} Applikation anfertigt, um den Entwickler einen unkomplizierten Einstieg in die existierende Logik zu ermöglichen, sowie die Entwickler-Fähigkeiten in der Forschung verteilter Systeme voranzutreiben.\bigbreak

\section{Aufbau der Arbeit} \label{sec:AdA}
	Die Abschlussarbeit beginnt mit der Einleitung der Grundalgen, die das Arbeiten mit Java näherbringt. Dazu gehören Konzepte wie der Klassenpfad, Klassenlader und Reflektion, die in der Umsetzung von \textsc{Renew} eine wichtige Rolle spielen. Anschließend werden aufbauende Entwurfsmuster und Prozeduren des Modulsystem von Java erläutert, die das bestehende Java System aktualisieren und neue Konzepte integrieren. Zum Schluss der Grundlagen werden Migrationsansätze vorgestellt, die gängige Migrationsarten abdecken und eine Übersicht über die möglichen Migrationsszenarien vorstellen.\newline 
	Das nachfolgende Kapitel der Ausgangssituation beschäftigt sich mit der Motivation der Arbeit, den daraus folgenden Zielen sowie Rahmenbedingungen. Darüber hinaus werden Auswirkungen des Modulsystems von Java und Gradle auf \textsc{Renew} erarbeitet, die \textsc{Renew} unterstützen und erweitern. Zusätzlich wird in diesem Kapitel der aktuelle Zustand der \textsc{Renew} Applikation konzipiert, der als Basis für die Prototypen dienen soll. \bigbreak 

	Als Teil der Umsetzung entstehen zwei Prototypen und ein Grundriss. Die zwei Prototypen rekonstruieren, die ausgewählte Teile von \textsc{Renew} modular und der Grundriss stellt eine mögliche Umsetzung des dynamischen Ladens der Plugins mithilfe des Modulsystem. Demzufolge wird die Codebasis sowie Design Entscheidungen bei Bedarf modernisiert und auf das Modulsystem von Java angepasst. Dabei soll der Schwerpunkt dieser Arbeit beim Erarbeiten einer modularen \textsc{Renew} Umsetzung liegen und demnach Plugins in erweiterbare Java Module transformieren.\newline
	Dafür wird die bestehende Projekt Konstruktion reorganisiert, sodass Plugins durch mehrere Module repräsentiert wenden können. Darauf aufbauend müssen Plugins die Moduleigenschaften einhalten und die entsprechenden Regeln und Konfigurationen erfüllen. Und zum Schluss wird die \textsc{Renew} Applikation mit einem modernen \textit{build} Werkzeug organisiert und für die Ausführung verpackt.\newline
	Das Ergebnis soll das Modularisierungskonzept in jedem Abschnitt des Lebenszyklus von \textsc{Renew} unterstützen. Daher wird erwartet, dass das modulare Denken in der Entwicklungsumgebung beim Entwickeln, beim Kompilieren und Verpacken sowie beim Ausführen der Applikation integriert wird. \bigbreak

	Das Ergebnis soll als Grundlage für das nächste Lebenszyklus von \textsc{Renew} dienen und die Entwicklung einfach, flexibel und erweiterbar gestalten. Dafür wir die Unterstützung von \textsc{Mulan} benötigt, welches die wesentliche Funktion von \textsc{Renew} voraussetzt. 
