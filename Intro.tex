\chapter{Einleitung}
\pagenumbering{arabic}

\section{Petrinetze} 
Das Konzept der Petrinetze wurde in der Arbeit von \textit{Carl Petri} beschrieben. 
Dieses besteht aus Stellen, Marken, Kanten und Transitionen, das nebenläufige und kommunizierende Prozesse darstellen kann.
Der ursprüngliche S/T-Netz Formalismus wurde mit der Zeit durch gefärbten Marken erweitert, mit dem Ziel äquivalente Strukturen zusammenzufassen und die darin befindlichen Marken zu typisieren.
Da die Struktur des Netzes immer noch stark zusammenhängend ist, bleibt die Organisation des Netzes schwer verständlich für das menschliche Auge. \newline 
Demzufolge sollte des Netzes auf logisch zusammenhänge Komponente aufgeteilt werden und trotzdem als ein Ganzes gelten.
Dieses Anforderung wird von den synchronen Kanälen umgesetzt, indem die Netzkomponenten anstelle der Kanten mit synchronen Kanälen verbunden werden und zwingen die mit einander verbunden Transitionen synchron zu schalten.
Hiermit ist eine Trennung des Netzes nach ihrer Funktionalität erreicht, die qualitativ anspruchsvolle Modelle komplexer und verteilter Systeme entwerfen lässt.\bigbreak
Obwohl das erweiterte Petrinetz anspruchsvolle Modellierungswerkzeug bietet, bleibt das gesamte Netzwerk statisch.
Demzufolge wurde der nächste Evolutionsschritt in der Entwicklung der Petrinetze mit den Referenznetz Formalismus gemacht. 
Dieser erlaubt dynamisch und bei Bedarf Netzinstanzen zu erstellen und diese als Marken in einem anderen Netz zu bewegen. 
Somit kann es mehrerer Instanzen eines Netzes geben, die mit unterschiedlicher Belegung im Petrinetz existieren. 

\section{Renew} 
Renew ist ein Petrinetz Simulator, der die oben genannten Petrinetz Formalismen unterstützt. Dieser ist in Java geschrieben und bietet eine Oberfläche zum Zeichnen und einen Simulator zum Ausführen der Netze. \newline 
Da die empfindliche monolithische Architektur von Olaf Kummer viel Fachwissen voraussetzte, wurde diese zu einem Plugin Verband von Jörn Schumacher zu Gunsten der Robustheit und Erweiterung umstrukturiert. Nun kann Renew über die Plugin Schnittstellen erweitert werden, ohne die existierende Logik zu beeinflussen. \bigbreak
Mit seiner Umsetzung delegierte Jörn Schumacher die Ausführung von Logik an Plugins und erstellte eine zentrale Instanz, die den Lebenszyklus bekannter Plugins verwaltet und koordiniert. Die zentrale Instanz nennt sich Plugin-Manager und kann das Verhalten von Renew mit Hilfe der Plugins modifizieren.
Der Plugin-Manager baut auf zwei primären Namespaces auf. Zum einen braucht dieser zusätzliche Bibliotheken zum verwalten seiner Umgebung und zum anderen braucht er Plugins, die Funktionalität mit sich bringen. 
\bigbreak 

\section{Gegenstand}
Mit der Plugin Architektur hat Renew ihren Lebenszyklus weit überschritten, denn der Plugin-Manager und die Kernfunktionalität blieb lang unverändert. An manchen stellen datiert die Code Basis aus dem Jahr 2002 (JDK 1.4). 
Somit entsprechen die erstmaligen Gestaltungsmöglichkeiten, Architekturentscheidungen und ihre Umsetzung, nicht mehr den aktuellen Stand der Technik (JDK 11). Besonders das neue Modulsystem von Java 9, das den JDK sowie den darauf aufbauenden Code modularisiert. 
Im Zuge dessen ist das Portieren der Applikation nicht mängelfrei. Es ist unklar wie sich die benutzerdefinierten Namensräume und die so gut wie unberührten Kern-Plugins auf die neuen Modulstruktur übertragen lassen. Zumal die Suche nach zusätzlichen Plugin-Code eine zentrale Funktion in System vertretet.\bigbreak
Indem die Applikation neu strukturiert wird, tauchen zusätzliche Mängel in den erweiternden Plugins. Die Plugin Entwickler  konzentrierten sich auf ihren Plugin und kapselten Code in sich, der Logisch gesehen in andere Plugins gehören müsste. In der Konsequenz kann Code-Duplizierung und Probleme in der Verständlichkeit der Plugin-Abhängigkeiten entstehen.\newline
Beifolgend stellt sich die Frage: Wie Portierbar ist Renew und was muss getan werden damit der Umstieg auf Java 11 funktioniert. \bigbreak

\section{Ziel}% microservices 
- Ziel : Mikroservice
- Wieso Mikroservices? 
- Bis zum Ziel müssen die Plugins modularisiert werden
- Die Plugins müssen sinnvoll gesplittet und die Berechnungsaufgabe aufgeteilt werden.
- Es muss eine Kommunikationsinfrastruktur aufgestellt werden
- Es müssen Umsetzungen von verteilten System evaluiert werden. 

\section{Umsetzung}
% was muss getan werden um die Ziele zu erreichen, 
% was muss ich lesen lernen und analysieren,
% was kommt dabei raus 
- Java 9 und Module erste schritte zu Mikroservice und verteilten Anwendung  
\section{Aufbau der Arbeit}



Die Grafik zeigt eine Übersicht über die Architektur der Hamaube. Sie
verwendet mit Kafka, Cassandra, Elasticsearch und Spark Tools aus dem
NoSQL-Bereich. Verbunden werden diese über Mikroservices zu einem
funktionierenden Ganzen.
