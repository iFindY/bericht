\chapter{Grundlagen} \label{cha:Grundlagen}
  In diesem Kapitel werden Begriffe und Konzepte vorgestellt, die für die Umsetzung dynamischer Java Systeme notwendig sind. Zuerst wird der Aufgabenbereich der virtuellen Maschine von Java erläutert, die für den Betrieb jeder Java-Applikation eine Grundlage liefert. Folgend werden die einzelnen Aufgabenbereiche und die Konzepte der JVM(virtuellen Maschine von Java) in einzelnem betrachtet und das Arbeiten mit dem Java-Code vorgestellt. Dafür werden Konzepte des Klassenpfads, Klassenladers, Delegation, Schnittstellen und Reflexion präsentiert, die das Arbeiten mit dynamischem Java-Code ermöglichen und eine Grundlage für die \textsc{Renew} Plugin-Architektur darstellen. Darüber hinaus wird das \textit{Gradle} Werkzeug eingeführt, welches für das Erstellen ausführbarer Software zuständig ist und zukünftig eingesetzt werden soll. 

\section{Java Virtual Machine} \label{sec:JVM}

  % java einleitung
  Gemessen am Interesse der Anwender und an ihrer Verbreitung, ist Java die erfolgreichste Programmiersprache der letzten Jahrzehnten. Der Erfolg kam mit den Objektorientierten Konzepten und der Plattformunabhängigkeit. Diese Fähigkeiten brachten eine große und fähige Kommune zusammen, die sowohl aus der Wirtschaft, als auch aus dem Forschungsbereich, stammt. Dementsprechend ist Java im Laufe der Zeit durch Designmuster, Architekturkonzepte, Paradigmen und aktuellen Sicherheits-, sowie Industriestandards erweitert worden. Da \textsc{Renew} mithilfe der Java Plattform umgesetzt wurde, kann sie sich alle gegebenen Vorteile zunutze machen. \newline
  Einer der wichtigen Bausteine von Java, ist die virtuelle Maschine, die das Suchen, Laden und Ausführen einer Codebasis auf allen gängigen Betriebssystemen erlaubt. Demzufolge spielt das Laden von Klassen aus örtlich unabhängigen Komponenten eine große Rolle für die entstandene \textsc{Renew} Architektur, denn die Plugins müssen gefunden, geladen und kommunikationsfähig eingerichtet werden, sodass sie sich gegenseitig nutzen und beeinflussen können.\bigbreak

  % Kapitelübersicht
  %In diesem Kapitel werden grundlegende Konzepte des \textit{ Klassenpfads, Klassenladers} und \textit{Reflexion} erläutert, mithilfe dessen die \textsc{Renew} Plugin- Architektur umgesetzt wurde.

\section{Klassenpfad} \label{sec:K}

  % Klassenpfad Einleitung
  Jede Java-Anwendung wird zuerst in einer für Menschen verständlichen Sprache geschrieben und anschließend in Byte-Code übersetzt. Infolgedessen ist der Code für die Ausführung Einsatzbereit, und wird anschließend an die virtuelle Maschine weiter gereicht.

  % Aufgabe des Klassenpfads 
  Um die kompilierten Klassen zu laden, werden von der virtuellen Maschine Ortsangaben mit den entsprechenden Codes erwartet. Die Ortsangaben nennt man \textit{ClassPath} oder Klassenpfad. Dieser beschreibt eine Liste von Orten, an denen sich die zur Ausführung benötigten Klassen befinden, wie zum Beispiel das lokale Dateisystem, das Netzwerk oder sogar einer Datenbank. 

  % Ergebnis des Klassenpfad
  Nachdem der Klassenpfad für die entsprechenden Klassenlader gesetzt ist, kann das \textit{Klassenlader-System} die gewünschten Klassen erfassen und in die virtuelle Maschine laden.

  \begin{figure}[h]
    \includegraphics[width=\textwidth]{material/images/Classpath2.pdf}
    \caption{Java ClassPath}
    \label{fig:cps}
  \end{figure}

  % Klassenpfad Zusammensetzbar  
  Im Beispiel \ref{fig:cps} besteht der Klassenpfad aus einem Verzeichnis \textit{classes}, sowie einem \textit{Print.jar} Archiv, welche die für die Ausführung nötige Klassen umfassen. Da beide Orte eine Dateistruktur beinhalten, unterliegen sie einer Einschränkung: Beide müssen die Paketstruktur der Java Klassen widerspiegeln, sodass der \textit{Applikation Klassenlader} diese durchsuchen kann. Anschließend braucht Java einen Startpunkt, mit dem die Applikation ihre Ausführung beginnt. 

  % Classloading mit Richtung 
  Beim Starten der Applikation werden Klassen instanziiert, indem der Klassenpfad, von links nach rechts, nach dem benötigten Typ durchsucht wird und den gefunden Objekttyp der Applikation zur Verfügung stellt. Somit hat der Klassenpfad eine interne Ordnung und eine Abarbeitungsreihenfolge. 

  \begin{figure}[h]
    \includegraphics[width=\textwidth]{material/images/Classpath-Manifest2.pdf}
    \caption{Jar Classpath}
    \label{fig:cpa}
  \end{figure}

  % Erweitere Klassenpfad mit dem Manifest 
  Im Beispiel \ref{fig:cps} wurde explizit ein Applikationsklassenpfad gesetzt, der für die Ausführung benötigten Klassen zuständig ist. Für den Ablauf großer Applikationen mit vielen Abhängigkeiten, kann dieser ausgedehnt und komplex werden. Von daher bietet Java eine Archivstruktur, die einen standardisierten Aufbau, sowie zusätzliche Metainformation über den Container in sich trägt. 
  
  % Manifest Metainformation 
  Dank der Java Strukturrichtlinie \cite{classLoadingOracle}, befindet sich der komplette Inhalt eines Archivs auf dem Applikationsklassenpfad und kann zusätzlich in der \textit{manifest.mf} Datei erweitert werden. Die \textit{manifest.mf} spielt eine große Rolle in der Entwicklung von Java Applikation. Sie kann den Namen, die Version, den Entwickler und die Sicherheitsattribute tragen, die während der Laufzeit ausgewertet werden können. Zum Beispiel wird in \ref{fig:cpa} der Klassenpfad durch ein Archiv aus dem Web (\textit{https://localhost:8080/Print.jar}) erweitert und für die Ausführung genutzt. Des Weiteren beinhaltet die \textit{manifest.mf} einen Einstiegspunkt für die Ausführung, der auf eine Klasse mit der \textit{main} Methode verweist.\newline
  Somit kann die Applikation in einer kurzen und einfachen Form gestartet werden, da der Ausführungskontext durch die Struktur und die mitgelieferte Metainformation komplett ist. \cite{classLoadingOracle}


\section{Klassenlader}\label{sec:cl}

  % Aufteilung der Verantwortung 
  In den vorherigen Beispielen [\ref{fig:cps}, \ref{fig:cpa}] wurden die Bedeutungen und die Rollen des Klassenpfads, bis einschließlich Java Version 1.8, für die Applikation beschrieben. Die genannten Aufgaben werden von dem Klassenlader übernommen und verarbeitet. Somit ist der Klassenlader eine zentrale Einheit in jeder Applikation, die den Klassenpfad nach benötigten Java Klassen, für die Instanziierung der entsprechenden Typen, durchsucht. Dementsprechend ist es eine wichtige Aufgabe, die nicht von einem Klassenlader erfüllt werden kann und wird demzufolge, auf eine Menge von Klassenlader aus dem \textit{Klassenlader-System} aufteilt. 


  \subsection{Klassenlader-System} \label{sec:cls}

    % Gründe 
    Das \textit{Klassenlader-System} besteht aus drei integrierten Klassenladern, von denen jeder einen anderen Gültigkeitsbereich für das Laden der Klassen besitzt. Beim absteigen der Klassenlader-Hierarchie, wird der Umfang der verfügbaren Quellen breiter und weniger vertrauenswürdig. 

    \begin{figure}[h!]
      \centering
      \includegraphics[width=0.7\textwidth]{material/images/Classloader-Hierarhie2.pdf}
      \caption{Klassenlader-System \cite{classLoadingIntro}}
      \label{fig:cl}
    \end{figure}
    
    % Aufbau
    In der Klassenlader-Hierarchie befindet sich zuoberst der \textit{Bootstrap-Klassen- lader}. Dieser ist verantwortlich für das Laden der grundlegenden Java Klassenbibliotheken, wie zum Beispiel die Java-Core-API aus der \textit{rt.jar} (siehe Abbildung \ref{fig:cl}). Diese Klassen sind am vertrauenswürdigsten und werden zum Starten der virtuellen Maschine verwendet. Der Klassenlader für Erweiterungen kann Klassen  aus dem Standarderweiterungspaket im Erweiterungsverzeichnis \textit{lib/ext} dazu laden. Diese können Java-UI und kryptografische Erweiterungen beinhalten. Der darunterliegende \textit{Applikation Klassenlader} ist zuständig für den Applikations-Code und lädt Klassen aus dem allgemeinen Klassenpfad, einschließlich der zu startenden Anwendung. Zuletzt können benutzerdefinierte Klassenlader erstellt werden, die sich auf der unteren Ebene der Klassenlader-Hierarchie befinden und auf Drittanbieter Bibliotheken zugreifen können. Demzufolge sind diese Quellen nicht sicher genug, um diesen eine große Priorität zuzuweisen, wie die der geladenen Klassen des \textit{Bootstrap-Laders}. \bigbreak 
    % Delegierungsmodell übergang
    Das in \ref{fig:cl} abgebildete Klassenlader-System verhindert, dass der Code aus weniger sicheren Quellen vertrauenswürdige Core-API-Klassen ersetzt, indem derselbe Name als Teil der Core-API angenommen wird. Daraus folgt ein Delegierungsmodell, welches eindeutige Klassen garantiert, da die Klassensuche von oben nach unten, die Klassenlader-Hierarchie abarbeitet. \cite{classLoadingIntro} 
    

  \subsection{Delegierungsmodell} \label{sec:dm}
    
    % Suchalgorithmus  
    Das \textit{Klassenlader-System} aus der Abbildung \ref{fig:deligation} delegiert jede Anfrage zum Laden einer bestimmten Klasse zuerst an seinen übergeordneten Klassenlader, bevor der angeforderte Klassenlader versucht, die Klasse selbst zu laden. Jeder Klassenlader hält somit einen Verweis auf einen übergeordneten Klassenlader und ist Teil eines Klassenlader Baums, mit dem \textit{Bootstrap-Klassenlader} an der Wurzel. 

    % Rekursiv 
    Wenn eine Instanz einer bestimmten Klasse benötigt wird, prüft der Klassenlader, der die Anfrage bearbeitet, normalerweise vorab mit seinem übergeordneten Klassenlader. Der übergeordnete Klassenlader durchläuft wiederum den gleichen Prozess bis die Delegierungskette den \textit{Bootstrap-Klassenlader} erreicht. Sobald der \textit{Bootstrap-Klassenlader} erreicht wurde, beginnt die tatsächliche Suche nach der gewünschten Klasse.

    \begin{figure}[h]
      \centering
      \includegraphics[width=0.9\textwidth]{material/images/flussCL.pdf}
      \caption{Klassensuche \cite{Forman04javareflection}}
      \label{fig:deligation}
    \end{figure}

    % Sichtbarkeit und Hierarchie 
    Wenn während der Suche ein übergeordneter Knoten eine bestimmte Klasse findet, dann wird diese Klasse die Baumhierarchie abwärts bis zu der Anfrage delegiert. Andernfalls versucht der zuständige Klassenlader, als letzter die Klasse selbstständig zu laden. Dies bedeutet, dass eine Klasse normalerweise nicht nur in dem Klassenlader, der sie geladen hat sichtbar ist, sondern auch für alle untergeordneten Instanzen. Dies bedeutet auch, wenn eine Klasse von mehr als einem Klassenlader in einem Baum geladen werden kann, wird immer die Klasse des übergeordneten Klassenlader priorisiert. Dennoch wird vor jedem Laden der Klasse der Cash-Speicher des Klassenladers nach der gewünschten Instanz durchsucht. Wenn diese Instanz existiert, wurde die Suche bereits zuvor durchgeführt und keiner der übergeordneten Klassenlader, außer dem Jetzigem, war fähig, die Anfrage zu beantworten. Somit kann die Suche beschleunigt werden, indem der Typ sofort zurückgegeben wird. \cite{parentDelegationModel}


  \subsection{Namensräume} \label{sec:nam}

    Geladene Klassen werden sowohl durch den Klassennamen, als auch durch den Klassenlader eindeutig identifiziert. Demzufolge werden geladene Klassen in \textit{Namensräume} unterteilt, die vom \textit{Klassenlader-System} individuell behandelt werden \cite{namespaces}. 

    % Idee 
    Ein \textit{Namensraum} ist eine Gruppe von Klassennamen, die von einem bestimmten Klassenlader geladen worden sind. Wenn ein Eintrag für eine Klasse einem \textit{Namensraum} hinzugefügt wurde, ist es nicht möglich, eine andere Klasse mit demselben Namen und unterschiedlichen Inhalt in den gleichen \textit{Namensraum} einzubinden. Nichtsdestotrotz können mehrere Kopien einer beliebigen Klasse in die Applikation geladen werden, indem für jede Klasse ein Klassenlader mit dem separaten \textit{Namensraum} erstellt wird \cite{customClDiffSpace}. 

    \begin{figure}[h]
      \centering
      \includegraphics[width=0.9\textwidth]{material/images/namespace.pdf}
      \caption{Namensräume \cite{customClDiffSpace}}
      \label{fig:nam}
    \end{figure}

    % Ungleichheit identischer Klassen 
    Die Abbildung \ref{fig:nam} zeigt ein Beispiel für eine Klassenidentitätskrise, die sich ergibt, wenn eine Schnittstelle und die zugehörige Implementierung jeweils von zwei separaten Klassenladern geladen werden. Obwohl die Namen und binären Implementierungen der Schnittstellen und Klassen gleich sind, kann eine Instanz der Klasse von einem Klassenlader nicht als Implementierung des Interfaces von dem anderen Klassenlader erkannt werden (siehe Abbildung \ref{fig:nam} \textit{MyPrint instanceof iPrint} Vergleich). Auf Wunsch kann dieser Umstand gelöst werden, indem die  Schnittstelle eine Ebene höher rutscht und von dem Applikation Klassenlader geladen wird. Somit implementieren beide \textit{Print} Klassen dieselbe Schnittstelle.\bigbreak 

    % Schutz des Codes 
    Der Klassen Namensraum bietet zusätzliche Sicherheitsfunktionen, wie die Kapselung privat deklarierter Pakete. Denn die Namensräume verhindern, dass der weniger vertrauenswürdiger Code, der aus der Applikation oder benutzerdefinierte Klassenlader geladen worden ist, direkt mit mehr vertrauenswürdigen Klassen interagieren kann. Beispielsweise wird die Kern-API vom \textit{Bootstrap-Klassenlader} geladen. Diese kann \textit{Package Private} Code enthalten, der bei Anfrage nicht an die unterliegenden Klassenlader weitergereicht wird.


    % Schutz der privaten Pakete 
    Auch wenn ein untergeordneter Klassenlader die Paketstruktur der Core-API nachahmt, wird diese nicht als Teil der Java Core-API anerkannt, da dieser von dem falschen Klassenlader geladen wurde. Somit verhindert die Verwendung von Namensräumen die Möglichkeit, spezielle Zugriffsberechtigungen auf private Pakete zu erhalten, indem diesen selbst geschriebenen Code zuweist. \cite{Forman04javareflection}


\section{Schnittstellen} \label{sec:kap}
  
  % Funktion 
  Die Schnittstelle und deren Implementierung, spielt eine entscheide Rolle für das Nutzen der Klassenfähigkeit. Eine Schnittstelle ist ein Vertrag, der die Funktionalität aller Klassen, die den Vertrag implementieren beschreibt. Wenn eine Klasse eine bestimmte Schnittstelle implementiert, verspricht sie die Umsetzung aller in der Schnittstelle deklarierten Methoden.

  \begin{figure}[h!]
    \centering
    \includegraphics[width=0.8\textwidth]{material/images/Classpath-Interface-Implimentation.pdf}
    \caption{Schnittstelle}
    \label{fig:schnitt}
  \end{figure}

  % ist ein Garantie
  Somit wird durch die eigene Umsetzung des Schnittstellenvertrags ein mögliches Verhalten für die Nutzer der Schnittstellenbeschreibung implementiert und garantiert den vereinbarten Rückgabewert für die angeforderte Funktion. \cite{bloch2017effective}\bigbreak 
  
  % Dynamische Klassenbindung 
  Im Beispiel \ref{fig:schnitt} wird der Vorteil des Schnittstellenvertrags demonstriert, der das Ausführen der unbekannten \textit{PrintImpl} Umsetzung, durch eine einfache \textit{IPrint}-Schnittstellenbeschreibung garantiert. Solange die Implementation sich auf derselben Klassenpfadhierarchie wie die Schnittstelle befindet, wird diese während der Laufzeit auf Kompatibilität geprüft und angewandt. Somit können dynamische Klassenbindungen während der Laufzeit entstehen und Laufzeitbibliotheken ausgetauscht werden, ohne dass die Applikation verändert wird. Hätte man die Schnittstelle nicht genutzt, würde man die Implementation nur als ein Objekt Type instanziieren können und hätte keinen einfachen Zugriff auf ihre Methoden. In der Konsequenz verbirgt die Schnittstelle ihre Implementierungsdetails der Methoden und gewährt den Vertragspartner keinen Einblick in ihre Umsetzung. Daraus folgt eine einfache Ersetzbarkeit der Implementationsvertreter, ohne den Klienten anpassen zu müssen. \cite{Forman04javareflection}

\section{Plugin Konzept} \label{sec:pm}
  Eine Plugin-Architektur definiert eine Erweiterungsspezifikation, die externen Code in die Applikation lädt und diese zu einem späteren Zeitpunkt entfernt, ohne alle Details der Codebasis im Voraus zu kennen \cite{Duvigneau09}. Somit müssen die Plugins einem Kommunikationsvertrag eingehen und befolgen, um eine Kommunikation mit der Kernapplikation aufnehmen zu können. Der Kommunikationsvertrag wird mit einem \textit{Interface} umgesetzt, auf das sich beiden Kommunikationspartner einigen. Das UML-Diagramm \ref{fig:pluginUMLD} veranschaulicht die Beziehung zwischen den Plugins und dem Plugin-Manager der Kernapplikation. \bigbreak
  \begin{figure}[h!]
    \centering
    \includegraphics[width=0.6\textwidth]{material/images/pluginKonzept.pdf}
    \caption{UML Diagramm für das Plugin-Muster \cite{tubiblio36573}}
    \label{fig:pluginUMLD}
  \end{figure}
  % Der Plugin Manager % einer der aufgaben 
  Der \textit{Plugin Manager} ist zuständig für das Erfassen, sowie Einlesen der Plugin Codebasis in den Arbeitsspeicher und für die Verwaltung des dazugehörigen Lebenszyklus. Dieses umfasst alle möglichen Plugin-Zustände während ihrer Laufzeit. Für aufeinander basierende Plugins ist die Struktur strikt, da die Plugins auf bestimmten Drittanbieter, sowie Plugin-Bibliotheken aufgebaut sind und diese für die Ausführung benötigten. Wenn die Einlesereihenfolge der Plugins nicht stimmt oder erwartete Plugins nicht präsent sind, vermisst der Klassenpfad die von dem Plugin angeforderte Klasse und führt zu einem Startabbruch der gesamten Applikation. Daher ist das Laden der Drittanbieter-Bibliotheken und der Plugins in der vorgegebenen Reihenfolge eine verantwortungsvolle Aufgabe. \cite{tubiblio36573} 

\section{Reflexion}\label{sec:refl}
  % Kurze einleitung 
  Reflexion ist die Fähigkeit eines laufenden Programms, sich selbst und seine Softwareumgebung zu analysieren und zu ändern. 
  Somit hat die Applikation eine Möglichkeit, durch Reflexion, die Information über ihre Struktur und ihr Verhalten zu erhalten, um wichtige Entscheidungen zu treffen. Je nachdem welche Information durch die Untersuchung eigener Klassen ausgelesen wurde, können Objekte, die während der Kompilierung nicht präsent waren, mithilfe der Reflexion-API während der Laufzeit instanziiert, bearbeitet und genutzt werden. Somit ermöglicht die Reflexion das Arbeiten mit Klassen, von denen man im Voraus nicht wissen kann, wie zum Beispiel von Klassen, die in der Zeit nach der Applikation, entstanden sind.\bigbreak 
 % Überblick: Problemstellung die Reflexion löst 
  In vielen Fällen der Applikationsentwicklung möchte man die Applikation von anderen Nutzern und Entwicklern erweitern lassen, ohne dass diese bei jeder Änderung die komplette Applikation umbauen müssen. Somit stellt sich die Frage, wie man ein Mechanismus erstellt, der mit beliebigen Klassen arbeiten kann.\newline
  Man könnte mit dem zuvor vorgestellten Schnittstellen- und Implementierungsansatz eine gemeinsame Schnittstelle für Erweiterungen definieren, die die Applikation mit einer Implementation erweitern lässt und die entsprechenden Methoden definiert. Nichtsdestotrotz besteht die Applikation nicht nur aus unserem Code, sondern zusätzlich aus einem Kern und und den dazugehörigen Drittanbieter-Bibliotheken, über die wir keine Kontrolle verfügen. Somit ist die Erweiterung der gesamten Codebasis mit der entsprechenden Schnittstelle oder eine Verschachtelung von \textit{instanceof} Blöcken, keine simple beziehungsweise saubere Lösung. Dementsprechend sollte Reflexion genutzt werden. Diese ermöglicht den Einblick in die Klassenstruktur, ohne direkt den Typen zu kennen. Die Klassenstruktur enthält Informationen über die Klasse selbst, zum Beispiel das Paket, die Superklasse der Klasse und die von der Klasse implementierten Schnittstellen. Darüber hinaus enthält es auch Details zu den, von der Klasse definierten Konstruktoren, Feldern und Methoden.\bigbreak

  \begin{figure}[h!]
    \centering
    \includegraphics[width=0.8\textwidth]{material/images/flussReflection.pdf}
    \caption{Aufruf einer Methode \cite{Forman04javareflection}}
    \label{fig:refl-fluss}
  \end{figure}

  % Sequenzdiagram 
  In der Abbildung \ref{fig:refl-fluss} wird ein Ablauf eines Methodenaufrufs mithilfe von Reflexion visualisiert. Im ersten Schritt muss die Methode gefunden werden. Da wir den Typen nicht kennen und nur für den Stammobjekttypen deklarierten Methoden nutzen können, lassen wir das Objekt sich selbst inspizieren und die geforderte Methode finden. Dafür wird nach einer bestimmten Methode der Klasse gesucht und bei Erfolg, ein Objekt von Typ \textit{Method} zurückgegeben. Das Methodenobjekt enthält die ganze Information über die gesuchte Methode, wie zum Beispiel Parameter und Rückgabewerte. Ausgerüstet mit der benötigten Information, kann die Methode dann ausgeführt werden. Dafür braucht das Methodenobjekt eine Instanz der passenden Klasse, sowie für die Ausführung benötigten Parameter. Nach der Abwickelung wird das Ergebnis der Ausführung vom der Objektinstanz über das Methodenobjekt zurück in den Programmfluss delegiert. \cite{Forman04javareflection} 

 % Nutzen: Felder Methode, Konstruktoren
  \bigbreak Somit sind die drei Hauptmerkmale einer Klasse, ihr Felder, Methoden und Konstruktoren durch eine entsprechendes Java Objekt aus der Reflexion-API, repräsentiert. 

  \begin{itemize}
    \item java.lang.reflect.Field
    \item java.lang.reflect.Method
    \item java.lang.reflect.Constructor
  \end{itemize}

  Mithilfe des Klassentyps können die oben genannten Objekte erzeugt und manipuliert werden. Diese bieten Schnittstellen für das Abfragen der Klassenstruktur an und repräsentieren Charakteristika der entsprechenden Klassen.

  \begin{itemize}
    \item Field[ ] *.class.getFields();
    \item Method[ ] *.class.getDeclaredMethods();
    \item Constructor[ ] *.class.getConstructors();
  \end{itemize}
  \bigbreak 

  Um den Zusammenhang und den Nutzen von Reflexion darzustellen, wird in der Abbildung \ref{my-refl} ein Szenario durchgespielt, das eine unbekannten Typen mithilfe des Konstruktors initialisiert, dessen Methoden aufruft, das Feld bearbeitet und wiedergibt, ohne dabei Objektstruktur im Voraus zu kennen. Des Weiteren ist zu beachten, dass statische Klassenmethoden, sowie private Felder und Methoden mithilfe von Reflexion offen zugänglich gemacht werden können.\cite{Forman04javareflection}\bigbreak 

  % Bild mit Code der eine Objekt erstellt und Methoden aufruft. Mit Kommentaren zwischen den Zeilen.
  \begin{lstlisting}[caption=Reflexion in Aktion,label=my-refl,captionpos=b]
    public static void getMethods(@NotNull Class clazz) throws
            NoSuchMethodException, NoSuchFieldException,
           InvocationTargetException, InstantiationException,
           IllegalAccessException {
      Method method;

        // Instantiierung
        Constructor[] ctors = clazz.getDeclaredConstructors();
        Object dynamic = ctors[0].newInstance(4);
        // Aufruf einer privaten Methode
        method = clazz.getDeclaredMethod("print", String.class);
        method.setAccessible(true);
        method.invoke(dynamic,"Hello World");
        // Feld Manipulation
        Field field = clazz.getDeclaredField("version");
        field.set(dynamic, 5);
        int version = (int) field.get(dynamic);
        System.out.println(version);
    }
  \end{lstlisting}

 % Wo wird Reflexion genutzt, wieso ist es so nützlich in der Modernen Software-Entwicklung 
  Wie in der Abbildung \ref{my-refl} dargestellt, ist Reflexion ein mächtiges Werkzeug, das aus der modernen Softwareentwicklung nicht wegzudenken ist und wird in zahlreichen Framework's verwendet, um den Entwickler zu unterstützen. 

  \begin{itemize}
    \item Zum Beispiel wird \textit{Dependency Injection} mithilfe von Reflexion realisiert, indem ein Framework, wie zum Beispiel Spring, die entsprechende Implementierung für ein Interface sucht und initiiert. In diesem Zusammenhang wird anhand des \textit{implement} Schlüssels und zusätzlicher Metainformation aus der Klassen \textit{Annotation} ein eindeutiger Kandidat auserwählt und konstruiert.
    \item Beim Serialisieren und Deserialisieren von Objekten werden die Objektfelder in JSON und wieder zurückkonvertiert, ohne die Feldnamen, sowie ihre Anzahl zu kennen.
    \item Die Web-Container Tomcat oder WildFly leiteten die Web-Anfragen an das entsprechende Modul durch das Analysieren der \textit{web.xml} und Anfordern der passenden URI.
    \item JUnit verwendet Reflexion, um die Methoden einer Klasse nach Test-Annotation zu durchsuchen, um diesen anschließend aufzurufen.
  \end{itemize}



\section{Gradle}
Gradle ist ein Build-Tool ähnlich wie Maven und Ant. Gradle ist das neueste dieser drei Build-Tools und wird zunehmend eingesetzt. Es ist Open Source und hat viel Akzeptanz bei den Entwicklern gefunden, da es auf die Erfahrung aus den vorhandenen genannten Build-Tools zurückgreift. Mehrere bekannte Projekte wie Android, Spring Framework und Hibernate haben ihre Build-Systeme bereits auf Gradle migriert. Einige der Vorteile, die Gradle gegenüber Maven und Ant hat, sind präzisere Erstellungsskripte und eine flexiblere Erstellungssprache.\bigbreak

\subsection{Beweggründe}
Für die Migration von Ant auf Gradle werden im Folgenden die Schwächen von Ant gegenüber Gradle aufgelistet.
\begin{itemize}
  \item Die Verwendung von XML als Definitionssprache für die Erstellungslogik führt zu übermäßig großen und ausführlichen Erstellungsskripten im Vergleich zu Erstellungswerkzeugen mit einer prägnanteren Definitionssprache. \cite{muschko2014gradle}
  \item Komplexe Erstellungslogik führt zu langen und nicht verwaltbaren Erstellungsskripten. Der Versuch, bedingte Logik wie \textit{if-then}, \textit{for-each} oder \textit{while} Anweisungen mit XML zu definieren, wirkt unnatürlich und aufgeblasen.\cite{muschko2014gradle}
  \item Ant gibt keine Richtlinien zum Einrichten des Projekts. In einem Unternehmen führt dies häufig zu einer Build-Datei, die jedes Mal anders aussieht.\cite{berglund2011building}
  \item Gemeinsame Funktionen werden häufig kopiert und eingefügt. Jeder neue Entwickler im Projekt muss die individuelle Struktur eines Builds verstehen.\cite{varanasi2015introducing}
  \item Die Verwendung von Ant ohne Ivy erschwert das Verwalten von Abhängigkeiten. In vielen Fällen müssen die JAR-Dateien in die Versionskontrolle eincheckt und deren Organisation manuell verwaltet werden.\cite{varanasi2015introducing}
\end{itemize}

\subsection{Aufbau der Umgebung}
  Die Gradle-Umgebung besteht aus mehreren Komponenten. Jede von diesen wird in einem bestimmten Lebenszyklus von Gradle für das Erstellen der Applikation genutzt.\newline
  Um Gradle zu starten, werden zwei ausführbare Skripte mitgeliefert. Für die Ausführung auf dem \textit{Unix} basierte Systeme kann \textit{gradlew} verwendet werden, und für die Windows Ausführung ist das \textit{gradlew.bat} Skript zuständig.\bigbreak
  \begin{figure}[h!]
    \centering
    \begin{minipage}{7cm}
      \dirtree{%
       .1 .
       .1 build.gradle.
       .1 gradle.
       .2 wrapper.
       .3 gradle-wrapper.jar.
       .3 gradle-wrapper.properties.
       .1 gradlew.
       .1 gradlew.bat.
       .1 settings.gradle.
       }
    \end{minipage}
    \caption{Gradle Konfiguration \cite{gradleStructure}}
    \label{fig:gradle_project_structure}
  \end{figure}

  Nach dem Anstoßen des Ausführungsskripts, wird Gradle konfiguriert und setzt eine bestimmte Zielversion für die Ausführung fest. Dies geschieht innerhalb der \textit{gradle/wrapper} Ordnerstruktur und initiiert Gradle für die Ausführung. Als nächstes sammelt Gradle die Information über alle Teilnehmer der Projektorganisation und legt eine globale Projektstruktur für die Ausführung fest. Dafür wird in der Initialisierungsphase die \textit{settings.gradle} der Projekte und die Lokale \textit{init.gradle} Konfigurationsdatei ausgelesen. Diese bestimmen Umgebungsvariablen, Eigenschaften und die persönlichen Informationen. Des Weiteren werden teilnehmende Projekte gesetzt und instanziiert.\newline
  Nachdem die Initialisierungsphase beendet ist, werden erstellte Projekte konfiguriert. Die Konfiguration geschieht laut der \textit{build.gradle} Konfigurationsdatei und bereitet die Projekte für die Ausführung vor. Zum Schluss wird das Bauen durchgeführt, indem eine Reihe von Ausführungsschritten (Tasks) von dem Nutzer aufgerufen werden.\cite{mitra2015mastering}


\subsection{Beispiel Skript}
\begin{lstlisting}[caption=Gradle in Aktion \cite{ikkink2015gradle},label=my-grl,captionpos=b]
  // Deklaration ders genutzten Plugins 
  plugins {
      id 'java'
  }
  // Bibliothek Quellen 
  repositories {
      mavenCentral()
  }
  //Projektbindung
  dependencies {
      compile('javax:javaee-web-api:8.0')
  }
  // Klassenpfade 
  configurations {
    libs
    plugins
    compile
  }
  // Felder
  group 'de.firm'
  description 'my first application'
  version version
  defaultTasks 'war'
  // Projektstruktur
  sourceSets {
      main {
          java {
              srcDirs ['src/main/java']
              webAppDirName 'src/main/webapp'
              outputDir file('out/classes')
          }
          resources {
              srcDirs ['src/main/resources']
              output.resourcesDir = file('out/resources')
          }
      }
  }
  // Konfiguration eines Abarbeitungsschritts
  task war {
      setGroup("gradle")
      setArchivesBaseName(name)
      webInf {
          into('classes') {
              from sourceSets.main.java.outputDir
              into('META-INF') {
                  from(sourceSets.main.resources.files) {
                      include("persistence.xml")
                  }

              }
          }
      }
      metaInf {
          from(sourceSets.main.resources) {
              include("import.sql")
          }
          manifest {
              attributes 'version': war_version
              attributes 'description': war_description
              attributes 'creator': war_creator
              attributes 'classifier': war_classifier
          }
      }
  }
  // Task Graph Manipulation 
  deploy.dependsOn(war)
\end{lstlisting}

In der Abbildung \ref{my-grl} ist eine Standardstruktur eines Gradle-Build-Skript abgebildet, die mit einem Java-Plugin ein \textit{war} Archiv erstellt. 
